function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import _regeneratorRuntime from "@babel/runtime/regenerator";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import invariant from 'invariant';

/**
 * Calc id from string or object
 */
var createGetId = function createGetId() {
  var idCache = new Map();
  return function (objectId) {
    var cachedId = idCache.get(objectId);

    if (cachedId) {
      return cachedId;
    } // WARNING: id should be unique after serialize.


    var id = JSON.stringify(objectId);
    invariant(id, 'params should be not null value');
    idCache.set(objectId, id);
    return id;
  };
};

export var LoaderStatus;

(function (LoaderStatus) {
  LoaderStatus[LoaderStatus["idle"] = 0] = "idle";
  LoaderStatus[LoaderStatus["loading"] = 1] = "loading";
  LoaderStatus[LoaderStatus["fulfilled"] = 2] = "fulfilled";
  LoaderStatus[LoaderStatus["rejected"] = 3] = "rejected";
})(LoaderStatus || (LoaderStatus = {}));

var createLoader = function createLoader(id) {
  var initialData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    loading: false,
    reloading: false,
    data: undefined,
    error: undefined
  };
  var loaderFn = arguments.length > 2 ? arguments[2] : undefined;
  var skip = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var promise;
  var status = LoaderStatus.idle;
  var data = initialData.data,
      error = initialData.error;
  var hasLoaded = false;
  var handlers = new Set();

  var load = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!skip) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", promise);

            case 2:
              if (!(status === LoaderStatus.loading)) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", promise);

            case 4:
              status = LoaderStatus.loading;
              notify();
              promise = new Promise(function (resolve) {
                loaderFn() // eslint-disable-next-line promise/prefer-await-to-then
                .then(function (value) {
                  data = value;
                  error = null;
                  status = LoaderStatus.fulfilled;
                  notify();
                  resolve(value);
                }) // eslint-disable-next-line promise/prefer-await-to-then
                ["catch"](function (e) {
                  error = e instanceof Error ? "".concat(e.message) : e;
                  data = null;
                  status = LoaderStatus.rejected;
                  notify();
                  resolve(e);
                }) // eslint-disable-next-line promise/prefer-await-to-then
                ["finally"](function () {
                  promise = null;
                  hasLoaded = true;
                });
              });
              return _context.abrupt("return", promise);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function load() {
      return _ref.apply(this, arguments);
    };
  }();

  var getResult = function getResult() {
    return {
      loading: !hasLoaded && status === LoaderStatus.loading,
      reloading: hasLoaded && status === LoaderStatus.loading,
      data: data,
      error: error
    };
  };

  var notify = function notify() {
    handlers.forEach(function (handler) {
      handler(status, getResult());
    });
  };

  var onChange = function onChange(handler) {
    handlers.add(handler);
    return function () {
      handlers["delete"](handler);
    };
  };

  return {
    get result() {
      return getResult();
    },

    get promise() {
      return promise;
    },

    onChange: onChange,
    load: load
  };
};

/**
 * Create loaders manager. It's returned instance will add to context
 * @param initialDataMap used to initialing loader data
 */
export var createLoaderManager = function createLoaderManager(initialDataMap) {
  var managerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _managerOptions$skipS = managerOptions.skipStatic,
      skipStatic = _managerOptions$skipS === void 0 ? false : _managerOptions$skipS,
      _managerOptions$skipN = managerOptions.skipNonStatic,
      skipNonStatic = _managerOptions$skipN === void 0 ? false : _managerOptions$skipN;
  var loadersMap = new Map();
  var getId = createGetId();

  var add = function add(loaderFn, loaderOptions) {
    var id = getId(loaderOptions.params);
    var loader = loadersMap.get(id);

    if (!loader) {
      // ignore non-static loader on static phase
      var ignoreNonStatic = skipNonStatic && !loaderOptions["static"]; // ignore static loader on non-static phase

      var ignoreStatic = skipStatic && loaderOptions["static"];
      var skipExec = ignoreNonStatic || ignoreStatic;
      loader = createLoader(id, typeof initialDataMap[id] !== 'undefined' ? initialDataMap[id] : {
        data: loaderOptions.initialData
      }, loaderFn, // Todo whether static loader is exec when CSR
      skipExec);
      loadersMap.set(id, loader);
    }

    return id;
  };

  var get = function get(id) {
    return loadersMap.get(id);
  }; // check if there has pending loaders


  var hasPendingLoaders = function hasPendingLoaders() {
    var _iterator = _createForOfIteratorHelper(loadersMap.values()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var loader = _step.value;
        var promise = loader.promise;

        if (promise instanceof Promise) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return false;
  }; // waiting for all pending loaders to be settled


  var awaitPendingLoaders = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var pendingLoaders, _iterator2, _step2, _step2$value, id, loader, promise;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              pendingLoaders = [];
              _iterator2 = _createForOfIteratorHelper(loadersMap);

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  _step2$value = _slicedToArray(_step2.value, 2), id = _step2$value[0], loader = _step2$value[1];
                  promise = loader.promise;

                  if (promise instanceof Promise) {
                    pendingLoaders.push([id, loader]);
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              _context2.next = 5;
              return Promise.all(pendingLoaders.map(function (item) {
                return item[1].promise;
              }));

            case 5:
              return _context2.abrupt("return", pendingLoaders.reduce(function (res, _ref3) {
                var _ref4 = _slicedToArray(_ref3, 2),
                    id = _ref4[0],
                    loader = _ref4[1];

                res[id] = loader.result;
                return res;
              }, {}));

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function awaitPendingLoaders() {
      return _ref2.apply(this, arguments);
    };
  }();

  return {
    hasPendingLoaders: hasPendingLoaders,
    awaitPendingLoaders: awaitPendingLoaders,
    add: add,
    get: get
  };
};