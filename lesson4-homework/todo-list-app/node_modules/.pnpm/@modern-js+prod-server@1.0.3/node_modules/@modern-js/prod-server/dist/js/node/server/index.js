"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Server = void 0;

var _path = _interopRequireDefault(require("path"));

var _serverCore = require("@modern-js/server-core");

var _utils = require("@modern-js/utils");

var _metrics = require("../libs/metrics");

var _modernServerSplit = require("./modern-server-split");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Server {
  constructor(options) {
    this.options = void 0;
    this.serverImpl = _modernServerSplit.createProdServer;
    this.server = void 0;
    this.app = void 0;
    this.runner = void 0;
    options.logger = options.logger || _utils.logger;
    options.metrics = options.metrics || _metrics.metrics;
    this.options = options;
  }

  async init() {
    const {
      options
    } = this; // initialize server

    this.server = this.serverImpl(options); // create http-server

    this.app = await this.server.createHTTPServer(this.getRequestHandler()); // initialize server runner

    this.runner = await this.createHookRunner(); // runner can only be used after server init

    await this.server.onInit(this.runner);
    return this;
  }

  async close() {
    await this.server.onClose();
    await new Promise(resolve => this.app.close(() => {
      resolve();
    }));
  }

  listen(port = 8080, listener) {
    this.app.listen(process.env.PORT || port, () => {
      if (listener) {
        listener();
      }

      this.server.onListening(this.app);
    });
  }

  getRequestHandler() {
    return (req, res, next) => {
      const requestHandler = this.server.getRequestHandler();
      return requestHandler(req, res, next);
    };
  }

  async createHookRunner() {
    // clear server manager every create time
    _serverCore.serverManager.clear();

    const {
      options
    } = this;
    const {
      plugins = []
    } = options; // server app context for serve plugin

    plugins.forEach(p => {
      _serverCore.serverManager.usePlugin((0, _utils.compatRequire)(p.pluginPath));
    });
    const appContext = this.initAppContext();

    _serverCore.serverManager.run(() => {
      var _options$config$outpu;

      _serverCore.ConfigContext.set(this.options.config);

      _serverCore.AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
        distDirectory: _path.default.join(options.pwd, ((_options$config$outpu = options.config.output) === null || _options$config$outpu === void 0 ? void 0 : _options$config$outpu.path) || 'dist')
      }));
    });

    return _serverCore.serverManager.init({});
  }

  initAppContext() {
    var _config$output;

    const {
      options
    } = this;
    const {
      pwd: appDirectory,
      plugins = [],
      config
    } = options;
    const serverPlugins = plugins.map(p => ({
      server: p
    }));
    return {
      appDirectory,
      distDirectory: _path.default.join(appDirectory, ((_config$output = config.output) === null || _config$output === void 0 ? void 0 : _config$output.path) || 'dist'),
      sharedDirectory: _path.default.resolve(appDirectory, _utils.SHARED_DIR),
      plugins: serverPlugins
    };
  }

}

exports.Server = Server;