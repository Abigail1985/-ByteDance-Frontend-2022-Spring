function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import _regeneratorRuntime from "@babel/runtime/regenerator";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import { toSchemaCtor, Struct, NonStrict } from 'farrow-schema';
import { createSchemaValidator } from 'farrow-schema/validator';
import { HandleSuccess, InputValidationError, OutputValidationError } from "./response";

var getErrorMessage = function getErrorMessage(error) {
  var message = error.message;

  if (Array.isArray(error.path) && error.path.length > 0) {
    message = "path: ".concat(JSON.stringify(error.path), "\n").concat(message);
  }

  return message;
};

var HANDLER_WITH_SCHEMA = 'HANDLER_WITH_SCHEMA';
export var isSchemaHandler = function isSchemaHandler(input) {
  return input && (input === null || input === void 0 ? void 0 : input[HANDLER_WITH_SCHEMA]) === true;
};
export var isHandler = function isHandler(input) {
  return input && typeof input === 'function';
};
export var baseMatch = function baseMatch(schema, handler) {
  var validateApiInput = createRequestSchemaValidator(schema.request);
  var validateApiOutput = createSchemaValidator(toSchemaCtor(schema.response));

  var handle = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input) {
      var inputResult, output, outputResult;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              inputResult = validateApiInput(input);

              if (!inputResult.isErr) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return", InputValidationError(getErrorMessage(inputResult.value)));

            case 3:
              _context.next = 5;
              return handler(input);

            case 5:
              output = _context.sent;
              outputResult = validateApiOutput(output);

              if (!outputResult.isErr) {
                _context.next = 9;
                break;
              }

              return _context.abrupt("return", OutputValidationError(getErrorMessage(outputResult.value)));

            case 9:
              return _context.abrupt("return", HandleSuccess(output));

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function handle(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  return Object.assign(handle, _defineProperty({
    schema: schema
  }, HANDLER_WITH_SCHEMA, true));
};
export var match = baseMatch;

var createRequestSchemaValidator = function createRequestSchemaValidator(schema) {
  var descriptors = {};

  if (schema.params) {
    descriptors.params = schema.params;
  }

  if (schema.query) {
    descriptors.query = schema.query;
  }

  if (schema.data) {
    descriptors.data = schema.data;
  }

  if (schema.headers) {
    descriptors.headers = schema.headers;
  }

  if (schema.cookies) {
    descriptors.cookies = schema.cookies;
  }

  var RequestStruct = Struct(descriptors);
  return createSchemaValidator(NonStrict(RequestStruct));
};