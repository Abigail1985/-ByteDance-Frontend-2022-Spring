function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as path from 'path';
import { createPlugin, registerHook, useAppContext, AppContext, useResolvedConfigContext, mountHook } from '@modern-js/core';
import { createAsyncWaterfall } from '@modern-js/plugin';
import { createDebugger, fs } from '@modern-js/utils';
import clone from 'clone';
import { isRouteComponentFile } from "./utils";
const debug = createDebugger('plugin-analyze');
export const modifyEntryImports = createAsyncWaterfall();
export const modifyEntryExport = createAsyncWaterfall();
export const addRuntimeExports = createAsyncWaterfall();
export const modifyEntryRuntimePlugins = createAsyncWaterfall();
export const modifyEntryRenderFunction = createAsyncWaterfall();
export const modifyFileSystemRoutes = createAsyncWaterfall();
export const modifyServerRoutes = createAsyncWaterfall();
export const htmlPartials = createAsyncWaterfall();
export const beforeGenerateRoutes = createAsyncWaterfall();
export const addDefineTypes = createAsyncWaterfall();
registerHook({
  modifyEntryImports,
  modifyEntryExport,
  modifyEntryRuntimePlugins,
  modifyEntryRenderFunction,
  modifyFileSystemRoutes,
  modifyServerRoutes,
  htmlPartials,
  addRuntimeExports,
  beforeGenerateRoutes,
  addDefineTypes
});
export default createPlugin(() => {
  let pagesDir = [];
  let originEntrypoints = [];
  return {
    // eslint-disable-next-line max-statements
    async prepare() {
      /* eslint-disable react-hooks/rules-of-hooks */
      const appContext = useAppContext();
      const resolvedConfig = useResolvedConfigContext();
      /* eslint-enable react-hooks/rules-of-hooks */

      try {
        fs.emptydirSync(appContext.internalDirectory);
      } catch (_unused) {// FIXME:
      }

      const existSrc = await fs.pathExists(appContext.srcDirectory);
      await mountHook().addRuntimeExports();

      if (!existSrc) {
        const {
          routes
        } = await mountHook().modifyServerRoutes({
          routes: []
        });
        debug(`server routes: %o`, routes);
        AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
          existSrc,
          serverRoutes: routes
        }));
        return;
      }

      const [{
        getBundleEntry
      }, {
        getServerRoutes
      }, {
        generateCode
      }, {
        getHtmlTemplate
      }] = await Promise.all([import("./getBundleEntry"), import("./getServerRoutes"), import("./generateCode"), import("./getHtmlTemplate")]);
      const entrypoints = getBundleEntry(appContext, resolvedConfig);
      const defaultChecked = entrypoints.map(point => point.entryName);
      debug(`entrypoints: %o`, entrypoints);
      const initialRoutes = getServerRoutes(entrypoints, {
        appContext,
        config: resolvedConfig
      });
      const {
        routes
      } = await mountHook().modifyServerRoutes({
        routes: initialRoutes
      });
      debug(`server routes: %o`, routes);
      AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
        entrypoints,
        serverRoutes: routes
      }));
      pagesDir = entrypoints.map(point => point.entry);
      originEntrypoints = clone(entrypoints);
      await generateCode(appContext, resolvedConfig, entrypoints);
      const htmlTemplates = await getHtmlTemplate(entrypoints, {
        appContext,
        config: resolvedConfig
      });
      debug(`html templates: %o`, htmlTemplates);
      await mountHook().addDefineTypes();
      debug(`add Define Types`);
      AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
        entrypoints,
        checkedEntries: defaultChecked,
        existSrc,
        serverRoutes: routes,
        htmlTemplates
      }));
    },

    watchFiles() {
      return pagesDir;
    },

    async fileChange(e) {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      const appContext = useAppContext();
      const {
        appDirectory
      } = appContext;
      const {
        filename,
        eventType
      } = e;

      const isPageFile = name => pagesDir.some(pageDir => name.includes(pageDir));

      const absoluteFilePath = path.resolve(appDirectory, filename);
      const isRouteComponent = isPageFile(absoluteFilePath) && isRouteComponentFile(absoluteFilePath);

      if (isRouteComponent && (eventType === 'add' || eventType === 'unlink')) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const resolvedConfig = useResolvedConfigContext();
        const {
          generateCode
        } = await import("./generateCode");
        const entrypoints = clone(originEntrypoints);
        generateCode(appContext, resolvedConfig, entrypoints);
      }
    }

  };
}, {
  name: '@modern-js/plugin-analyze'
});