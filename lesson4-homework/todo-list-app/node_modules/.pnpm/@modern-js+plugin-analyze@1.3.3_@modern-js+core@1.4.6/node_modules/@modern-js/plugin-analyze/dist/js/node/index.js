"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.modifyServerRoutes = exports.modifyFileSystemRoutes = exports.modifyEntryRuntimePlugins = exports.modifyEntryRenderFunction = exports.modifyEntryImports = exports.modifyEntryExport = exports.htmlPartials = exports.default = exports.beforeGenerateRoutes = exports.addRuntimeExports = exports.addDefineTypes = void 0;

var path = _interopRequireWildcard(require("path"));

var _core = require("@modern-js/core");

var _plugin = require("@modern-js/plugin");

var _utils = require("@modern-js/utils");

var _clone = _interopRequireDefault(require("clone"));

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _utils.createDebugger)('plugin-analyze');
const modifyEntryImports = (0, _plugin.createAsyncWaterfall)();
exports.modifyEntryImports = modifyEntryImports;
const modifyEntryExport = (0, _plugin.createAsyncWaterfall)();
exports.modifyEntryExport = modifyEntryExport;
const addRuntimeExports = (0, _plugin.createAsyncWaterfall)();
exports.addRuntimeExports = addRuntimeExports;
const modifyEntryRuntimePlugins = (0, _plugin.createAsyncWaterfall)();
exports.modifyEntryRuntimePlugins = modifyEntryRuntimePlugins;
const modifyEntryRenderFunction = (0, _plugin.createAsyncWaterfall)();
exports.modifyEntryRenderFunction = modifyEntryRenderFunction;
const modifyFileSystemRoutes = (0, _plugin.createAsyncWaterfall)();
exports.modifyFileSystemRoutes = modifyFileSystemRoutes;
const modifyServerRoutes = (0, _plugin.createAsyncWaterfall)();
exports.modifyServerRoutes = modifyServerRoutes;
const htmlPartials = (0, _plugin.createAsyncWaterfall)();
exports.htmlPartials = htmlPartials;
const beforeGenerateRoutes = (0, _plugin.createAsyncWaterfall)();
exports.beforeGenerateRoutes = beforeGenerateRoutes;
const addDefineTypes = (0, _plugin.createAsyncWaterfall)();
exports.addDefineTypes = addDefineTypes;
(0, _core.registerHook)({
  modifyEntryImports,
  modifyEntryExport,
  modifyEntryRuntimePlugins,
  modifyEntryRenderFunction,
  modifyFileSystemRoutes,
  modifyServerRoutes,
  htmlPartials,
  addRuntimeExports,
  beforeGenerateRoutes,
  addDefineTypes
});

var _default = (0, _core.createPlugin)(() => {
  let pagesDir = [];
  let originEntrypoints = [];
  return {
    // eslint-disable-next-line max-statements
    async prepare() {
      /* eslint-disable react-hooks/rules-of-hooks */
      const appContext = (0, _core.useAppContext)();
      const resolvedConfig = (0, _core.useResolvedConfigContext)();
      /* eslint-enable react-hooks/rules-of-hooks */

      try {
        _utils.fs.emptydirSync(appContext.internalDirectory);
      } catch (_unused) {// FIXME:
      }

      const existSrc = await _utils.fs.pathExists(appContext.srcDirectory);
      await (0, _core.mountHook)().addRuntimeExports();

      if (!existSrc) {
        const {
          routes
        } = await (0, _core.mountHook)().modifyServerRoutes({
          routes: []
        });
        debug(`server routes: %o`, routes);

        _core.AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
          existSrc,
          serverRoutes: routes
        }));

        return;
      }

      const [{
        getBundleEntry
      }, {
        getServerRoutes
      }, {
        generateCode
      }, {
        getHtmlTemplate
      }] = await Promise.all([Promise.resolve().then(() => _interopRequireWildcard(require("./getBundleEntry"))), Promise.resolve().then(() => _interopRequireWildcard(require("./getServerRoutes"))), Promise.resolve().then(() => _interopRequireWildcard(require("./generateCode"))), Promise.resolve().then(() => _interopRequireWildcard(require("./getHtmlTemplate")))]);
      const entrypoints = getBundleEntry(appContext, resolvedConfig);
      const defaultChecked = entrypoints.map(point => point.entryName);
      debug(`entrypoints: %o`, entrypoints);
      const initialRoutes = getServerRoutes(entrypoints, {
        appContext,
        config: resolvedConfig
      });
      const {
        routes
      } = await (0, _core.mountHook)().modifyServerRoutes({
        routes: initialRoutes
      });
      debug(`server routes: %o`, routes);

      _core.AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
        entrypoints,
        serverRoutes: routes
      }));

      pagesDir = entrypoints.map(point => point.entry);
      originEntrypoints = (0, _clone.default)(entrypoints);
      await generateCode(appContext, resolvedConfig, entrypoints);
      const htmlTemplates = await getHtmlTemplate(entrypoints, {
        appContext,
        config: resolvedConfig
      });
      debug(`html templates: %o`, htmlTemplates);
      await (0, _core.mountHook)().addDefineTypes();
      debug(`add Define Types`);

      _core.AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
        entrypoints,
        checkedEntries: defaultChecked,
        existSrc,
        serverRoutes: routes,
        htmlTemplates
      }));
    },

    watchFiles() {
      return pagesDir;
    },

    async fileChange(e) {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      const appContext = (0, _core.useAppContext)();
      const {
        appDirectory
      } = appContext;
      const {
        filename,
        eventType
      } = e;

      const isPageFile = name => pagesDir.some(pageDir => name.includes(pageDir));

      const absoluteFilePath = path.resolve(appDirectory, filename);
      const isRouteComponent = isPageFile(absoluteFilePath) && (0, _utils2.isRouteComponentFile)(absoluteFilePath);

      if (isRouteComponent && (eventType === 'add' || eventType === 'unlink')) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const resolvedConfig = (0, _core.useResolvedConfigContext)();
        const {
          generateCode
        } = await Promise.resolve().then(() => _interopRequireWildcard(require("./generateCode")));
        const entrypoints = (0, _clone.default)(originEntrypoints);
        generateCode(appContext, resolvedConfig, entrypoints);
      }
    }

  };
}, {
  name: '@modern-js/plugin-analyze'
});

exports.default = _default;