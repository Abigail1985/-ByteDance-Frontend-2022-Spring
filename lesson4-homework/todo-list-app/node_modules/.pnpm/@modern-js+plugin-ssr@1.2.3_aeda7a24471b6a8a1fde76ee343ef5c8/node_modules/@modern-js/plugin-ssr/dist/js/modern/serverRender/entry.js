import path from 'path';
import { LOADABLE_STATS_FILE } from '@modern-js/utils/constants';
import React from 'react';
import ReactDomServer from 'react-dom/server';
import serialize from 'serialize-javascript';
import ReactHelmet from 'react-helmet';
import { toFragments } from "./template";
import { RenderLevel } from "./type";
import helmetReplace from "./helmet";
import { reduce } from "./reduce";
import * as loadableRenderer from "./loadable";
import * as styledComponentRenderer from "./styledComponent";

const buildTemplateData = (context, data, renderLevel) => {
  const {
    request
  } = context;
  return {
    data,
    context: {
      request: {
        params: request.params,
        query: request.query,
        pathname: request.pathname,
        host: request.host,
        url: request.url,
        headers: request.headers,
        cookieMap: request.cookieMap
      }
    },
    renderLevel
  };
};

export default class Entry {
  constructor(options) {
    this.entryName = void 0;
    this.result = void 0;
    this.App = void 0;
    this.fragments = void 0;
    this.fragments = toFragments(options.template);
    this.entryName = options.name;
    this.App = options.App;
    this.result = {
      renderLevel: RenderLevel.CLIENT_RENDER,
      html: '',
      chunksMap: {
        js: '',
        css: ''
      }
    };
  }

  async renderToHtml(context) {
    const {
      ssrContext
    } = context;

    if (ssrContext.redirection.url) {
      return '';
    }

    const prefetchData = await this.prefetch(context);

    if (ssrContext.redirection.url) {
      return '';
    }

    if (this.result.renderLevel >= RenderLevel.SERVER_PREFETCH) {
      this.result.html = this.renderToString(context);
    }

    if (ssrContext.redirection.url) {
      return '';
    }

    let html = '';
    const templateData = buildTemplateData(ssrContext, prefetchData, this.result.renderLevel);
    const SSRData = this.getSSRDataScript(templateData);

    for (const fragment of this.fragments) {
      if (fragment.isVariable && fragment.content === 'SSRDataScript') {
        html += fragment.getValue(SSRData);
      } else {
        html += fragment.getValue(this.result);
      }
    }

    const helmetData = ReactHelmet.renderStatic();
    return helmetData ? helmetReplace(html, helmetData) : html;
  }

  async prefetch(context) {
    const {
      App: {
        prefetch
      }
    } = this;
    let prefetchData;

    try {
      prefetchData = prefetch ? await prefetch(context) : null;
      this.result.renderLevel = RenderLevel.SERVER_PREFETCH;
    } catch (e) {
      // Todo report if render error or fetch data error. logic from prefetch.tsx
      this.result.renderLevel = RenderLevel.CLIENT_RENDER;
      console.error('SSR Error - App Prefetch error = %s', e);
    }

    return prefetchData || {};
  }

  renderToString(context) {
    let html = '';

    try {
      const App = /*#__PURE__*/React.createElement(this.App, {
        context: Object.assign(context, {
          ssr: true
        })
      }); // Todo render Hook

      const renderContext = {
        loadableManifest: path.resolve(context.ssrContext.distDir, LOADABLE_STATS_FILE),
        result: this.result,
        entryName: this.entryName
      };
      html = reduce(App, renderContext, [loadableRenderer.toHtml, styledComponentRenderer.toHtml, jsx => ReactDomServer.renderToString(jsx)]);
      this.result.renderLevel = RenderLevel.SERVER_RENDER;
    } catch (e) {
      console.error('SSR Error - App Render To HTML error = %s', e);
    }

    return html;
  }

  getSSRDataScript(templateData) {
    return {
      SSRDataScript: `
        <script>window._SSR_DATA = ${serialize(templateData, {
        isJSON: true
      })}</script>
      `
    };
  }

}