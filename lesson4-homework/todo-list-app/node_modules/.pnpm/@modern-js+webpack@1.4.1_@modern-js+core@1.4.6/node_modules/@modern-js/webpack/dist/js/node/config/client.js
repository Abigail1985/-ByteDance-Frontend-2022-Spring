"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClientWebpackConfig = void 0;

var _path = _interopRequireDefault(require("path"));

var _utils = require("@modern-js/utils");

var _htmlWebpackPlugin = _interopRequireDefault(require("html-webpack-plugin"));

var _webpackManifestPlugin = require("webpack-manifest-plugin");

var _webpack = require("webpack");

var _copyWebpackPlugin = _interopRequireDefault(require("copy-webpack-plugin"));

var _lodash = _interopRequireDefault(require("lodash.template"));

var _webpackBundleAnalyzer = require("webpack-bundle-analyzer");

var _inlineHtmlChunkPlugin = require("../plugins/inline-html-chunk-plugin");

var _appIconPlugin = require("../plugins/app-icon-plugin");

var _bottomTemplatePlugin = require("../plugins/bottom-template-plugin");

var _constants = require("../utils/constants");

var _base = require("./base");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const nodeLibsBrowser = require('node-libs-browser');

class ClientWebpackConfig extends _base.BaseWebpackConfig {
  constructor(appContext, options) {
    super(appContext, options);
    this.htmlFilename = void 0;

    this.htmlFilename = name => (0, _utils.removeLeadingSlash)(`${this.options.output.htmlPath}/${this.options.output.disableHtmlFolder ? name : `${name}/index`}.html`);
  }

  name() {
    this.chain.name('client');
  }

  entry() {
    super.entry();
    const entrypoints = Object.keys(this.chain.entryPoints.entries() || {});

    for (const name of entrypoints) {
      if (this.options.output.polyfill !== 'off') {
        this.chain.entry(name).prepend(require.resolve('regenerator-runtime/runtime')).prepend(require.resolve('core-js'));
      }
    }
  }

  resolve() {
    super.resolve(); // FIXME: local node_modules (WTF?)

    const wtfPath = _path.default.resolve(__dirname, '../../../../node_modules');

    this.chain.resolve.modules.add(wtfPath); // node polyfill

    if (!this.options.output.disableNodePolyfill) {
      this.chain.resolve.merge({
        fallback: this.getNodePolyfill()
      });
    }
  }

  getNodePolyfill() {
    return Object.keys(nodeLibsBrowser).reduce((previous, name) => {
      if (nodeLibsBrowser[name]) {
        previous[name] = nodeLibsBrowser[name];
      } else {
        previous[name] = false;
      }

      return previous;
    }, {});
  }

  getCustomPublicEnv() {
    const {
      metaName
    } = this.appContext;
    const prefix = `${metaName.split(/[-_]/)[0]}_`.toUpperCase();
    const envReg = new RegExp(`^${prefix}`);
    return Object.keys(process.env).filter(key => envReg.test(key));
  }

  useDefinePlugin() {
    const {
      envVars,
      globalVars
    } = this.options.source || {};
    const publicEnvVars = this.getCustomPublicEnv();
    this.chain.plugin('define').use(_webpack.DefinePlugin, [_objectSpread(_objectSpread({}, ['NODE_ENV', 'BUILD_MODE', ...publicEnvVars, ...(envVars || [])].reduce((memo, name) => {
      memo[`process.env.${name}`] = JSON.stringify(process.env[name]);
      return memo;
    }, {})), Object.keys(globalVars || {}).reduce((memo, name) => {
      memo[name] = globalVars ? JSON.stringify(globalVars[name]) : '';
      return memo;
    }, {}))]);
  } // eslint-disable-next-line max-statements


  plugins() {
    var _this$options$cliOpti;

    super.plugins();
    this.useDefinePlugin();
    (0, _utils.isDev)() && this.chain.plugin('hmr').use(_webpack.HotModuleReplacementPlugin);
    const {
      packageName
    } = this.appContext; // output html files

    const entrypoints = Object.keys(this.chain.entryPoints.entries() || {});

    for (const entryName of entrypoints) {
      const baseTemplateParams = _objectSpread({
        entryName,
        title: (0, _utils.getEntryOptions)(entryName, this.options.output.title, this.options.output.titleByEntries, packageName),
        mountId: this.options.output.mountId,
        assetPrefix: (0, _utils.removeTailSlash)(this.chain.output.get('publicPath')),
        meta: (0, _utils.generateMetaTags)((0, _utils.getEntryOptions)(entryName, this.options.output.meta, this.options.output.metaByEntries, packageName))
      }, (0, _utils.getEntryOptions)(entryName, this.options.output.templateParameters, this.options.output.templateParametersByEntries, packageName));

      this.chain.plugin(`html-${entryName}`).use(_htmlWebpackPlugin.default, [{
        __internal__: true,
        // flag for internal html-webpack-plugin usage
        filename: this.htmlFilename(entryName),
        chunks: [entryName],
        template: this.appContext.htmlTemplates[entryName],
        minify: !(0, _utils.isProd)() ? false : {
          collapseWhitespace: true,
          removeComments: false,
          removeRedundantAttributes: true,
          removeScriptTypeAttributes: true,
          removeStyleLinkTypeAttributes: true,
          useShortDoctype: true
        },
        favicon: (0, _utils.getEntryOptions)(entryName, this.options.output.favicon, this.options.output.faviconByEntries, packageName) || (0, _utils.findExists)(_constants.ICON_EXTENSIONS.map(ext => _path.default.resolve(this.appContext.appDirectory, this.options.source.configDir, `favicon.${ext}`))),
        inject: (0, _utils.getEntryOptions)(entryName, this.options.output.inject, this.options.output.injectByEntries, packageName),
        templateParameters: (compilation, assets, assetTags, pluginOptions) => _objectSpread({
          webpackConfig: compilation.options,
          htmlWebpackPlugin: {
            tags: assetTags,
            files: assets,
            options: pluginOptions
          }
        }, baseTemplateParams),
        bottomTemplate: this.appContext.htmlTemplates[`__${entryName}-bottom__`] && (0, _lodash.default)(this.appContext.htmlTemplates[`__${entryName}-bottom__`])(baseTemplateParams)
      }]);
    } // eslint-enable-next-line max-statements


    this.chain.plugin('bottom-template').use(_bottomTemplatePlugin.BottomTemplatePlugin, [_htmlWebpackPlugin.default]); // add app icon

    const appIcon = (0, _utils.findExists)(_constants.ICON_EXTENSIONS.map(ext => _path.default.resolve(this.appContext.appDirectory, this.options.source.configDir, `icon.${ext}`)));

    if (appIcon) {
      this.chain.plugin('app-icon').use(_appIconPlugin.AppIconPlugin, [_htmlWebpackPlugin.default, appIcon]);
    }

    this.chain.plugin('webpack-manifest').use(_webpackManifestPlugin.WebpackManifestPlugin, [{
      fileName: 'asset-manifest.json',
      publicPath: this.chain.output.get('publicPath'),
      generate: (seed, files, entries) => {
        const manifestFiles = files.reduce((manifest, file) => {
          manifest[file.name] = file.path;
          return manifest;
        }, seed);
        const entrypointFiles = Object.keys(entries).reduce((previous, name) => previous.concat(entries[name].filter(fileName => !fileName.endsWith('.map'))), []);
        return {
          files: manifestFiles,
          entrypoints: entrypointFiles
        };
      }
    }]);

    const configDir = _path.default.resolve(this.appDirectory, this.options.source.configDir);

    this.chain.plugin('copy').use(_copyWebpackPlugin.default, [{
      patterns: [...(this.options.output.copy || []), {
        from: '**/*',
        to: 'public',
        context: _path.default.posix.join(configDir.replace(/\\/g, '/'), 'public'),
        noErrorOnMissing: true,
        // eslint-disable-next-line node/prefer-global/buffer
        transform: (content, absoluteFrom) => {
          if (!/\.html?$/.test(absoluteFrom)) {
            return content;
          }

          return require('lodash.template')(content.toString('utf8'))({
            assetPrefix: (0, _utils.removeTailSlash)(this.chain.output.get('publicPath'))
          });
        }
      }, {
        from: '**/*',
        to: 'upload',
        context: _path.default.posix.join(configDir.replace(/\\/g, '/'), 'upload'),
        noErrorOnMissing: true
      }]
    }]);

    if ((0, _utils.isProd)()) {
      const {
        disableInlineRuntimeChunk,
        enableInlineStyles,
        enableInlineScripts
      } = this.options.output;
      this.chain.plugin('inline-html').use(_inlineHtmlChunkPlugin.InlineChunkHtmlPlugin, [_htmlWebpackPlugin.default, [enableInlineScripts && /\.js$/, enableInlineStyles && /\.css$/, !disableInlineRuntimeChunk && /runtime-.+[.]js$/].filter(Boolean)]);
    } // node polyfill


    if (!this.options.output.disableNodePolyfill) {
      this.chain.plugin('node-polyfill-provide').use(_webpack.ProvidePlugin, [{
        Buffer: [nodeLibsBrowser.buffer, 'Buffer'],
        console: [nodeLibsBrowser.console],
        process: [nodeLibsBrowser.process]
      }]);
    }

    if ((_this$options$cliOpti = this.options.cliOptions) !== null && _this$options$cliOpti !== void 0 && _this$options$cliOpti.analyze) {
      this.chain.plugin('bundle-analyze').use(_webpackBundleAnalyzer.BundleAnalyzerPlugin, [{
        analyzerMode: 'static',
        openAnalyzer: false,
        reportFilename: 'report.html'
      }]);
    }
  }

}

exports.ClientWebpackConfig = ClientWebpackConfig;