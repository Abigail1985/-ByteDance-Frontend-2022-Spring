function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// eslint-disable-next-line eslint-comments/disable-enable-pair

/* eslint-disable max-lines */
import { isPipeline, createPipeline, runWithContainer, createContainer } from 'farrow-pipeline';
import { isWaterfall, createWaterfall, isAsyncWaterfall, createAsyncWaterfall } from "../waterfall";
import { isWorkflow, createWorkflow, isAsyncWorkflow, createAsyncWorkflow, isParallelWorkflow, createParallelWorkflow } from "../workflow";
import { RunnerContext, useRunner } from "./runner"; // eslint-disable-next-line @typescript-eslint/no-invalid-void-type

const SYNC_PLUGIN_SYMBOL = 'SYNC_PLUGIN_SYMBOL';
export const DEFAULT_OPTIONS = {
  name: 'untitled',
  pre: [],
  post: [],
  rivals: [],
  required: []
};
export const createManager = processes => {
  let index = 0;

  const createPlugin = (initializer, options = {}) => _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_OPTIONS), {}, {
    name: `No.${index++} plugin`
  }, options), {}, {
    SYNC_PLUGIN_SYMBOL,
    initializer
  });

  const isPlugin = input => hasOwnProperty(input, SYNC_PLUGIN_SYMBOL) && input[SYNC_PLUGIN_SYMBOL] === SYNC_PLUGIN_SYMBOL;

  const registe = extraProcesses => {
    // eslint-disable-next-line no-param-reassign
    processes = _objectSpread(_objectSpread({}, extraProcesses), processes);
  };

  const clone = () => {
    let plugins = [];

    const usePlugin = (...input) => {
      for (const plugin of input) {
        if (isPlugin(plugin)) {
          if (!includePlugin(plugins, plugin)) {
            plugins.push(_objectSpread(_objectSpread({}, plugin), {}, {
              index: plugins.length
            }));
          }
        } else {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          console.warn(`Unknown plugin: ${plugin.name}`);
        }
      }

      return {
        createPlugin,
        isPlugin,
        usePlugin,
        init,
        run,
        clear,
        registe,
        useRunner,
        clone
      };
    };

    const clear = () => {
      plugins = [];
    };

    const currentContainer = createContainer();

    const init = options => {
      const container = (options === null || options === void 0 ? void 0 : options.container) || currentContainer;
      const sortedPlugins = sortPlugins(plugins);
      checkPlugins(sortedPlugins);
      const hooksList = sortedPlugins.map(plugin => runWithContainer(() => plugin.initializer(), container));
      return generateRunner(hooksList, container, processes);
    };

    const run = (cb, options) => {
      const container = (options === null || options === void 0 ? void 0 : options.container) || currentContainer;
      return runWithContainer(cb, container);
    };

    return {
      createPlugin,
      isPlugin,
      usePlugin,
      init,
      clear,
      run,
      registe,
      useRunner,
      clone
    };
  };

  return clone();
};
export const generateRunner = (hooksList, container, processes) => {
  const runner = {};
  const cloneShape = cloneProgressRecord(processes);

  if (processes) {
    for (const key in cloneShape) {
      for (const hooks of hooksList) {
        if (!hooks) {
          continue;
        }

        if (hooks[key]) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          cloneShape[key].use(hooks[key]);
        }
      } // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error


      runner[key] = (input, options) => cloneShape[key].run(input, _objectSpread({
        container
      }, options));
    }
  }

  container.write(RunnerContext, runner);
  return runner;
};
export const cloneProgress = progress => {
  if (isWaterfall(progress)) {
    return createWaterfall();
  }

  if (isAsyncWaterfall(progress)) {
    return createAsyncWaterfall();
  }

  if (isWorkflow(progress)) {
    return createWorkflow();
  }

  if (isAsyncWorkflow(progress)) {
    return createAsyncWorkflow();
  }

  if (isParallelWorkflow(progress)) {
    return createParallelWorkflow();
  }

  if (isPipeline(progress)) {
    return createPipeline();
  } // eslint-disable-next-line @typescript-eslint/restrict-template-expressions


  throw new Error(`Unknown progress: ${progress}`);
}; // eslint-disable-next-line @typescript-eslint/no-invalid-void-type

export const cloneProgressRecord = record => {
  if (!record) {
    return record;
  }

  const result = {};

  for (const key in record) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    result[key] = cloneProgress(record[key]);
  }

  return result;
};

const includePlugin = (plugins, input) => {
  for (const plugin of plugins) {
    if (plugin.name === input.name) {
      return true;
    }
  }

  return false;
};

const sortPlugins = input => {
  let plugins = input.slice();

  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];

    for (const pre of plugin.pre) {
      for (let j = i + 1; j < plugins.length; j++) {
        if (plugins[j].name === pre) {
          plugins = [...plugins.slice(0, i), plugins[j], ...plugins.slice(i, j), ...plugins.slice(j + 1, plugins.length)];
        }
      }
    }

    for (const post of plugin.post) {
      for (let j = 0; j < i; j++) {
        if (plugins[j].name === post) {
          plugins = [...plugins.slice(0, j), ...plugins.slice(j + 1, i + 1), plugins[j], ...plugins.slice(i + 1, plugins.length)];
        }
      }
    }
  }

  return plugins;
};

const checkPlugins = plugins => {
  for (const origin of plugins) {
    for (const rival of origin.rivals) {
      for (const plugin of plugins) {
        if (rival === plugin.name) {
          throw new Error(`${origin.name} has rival ${plugin.name}`);
        }
      }
    }

    for (const required of origin.required) {
      if (!plugins.some(plugin => plugin.name === required)) {
        throw new Error(`The plugin: ${required} is required when plugin: ${origin.name} is exist.`);
      }
    }
  }
};

export const hasOwnProperty = (obj, prop) => obj.hasOwnProperty(prop);