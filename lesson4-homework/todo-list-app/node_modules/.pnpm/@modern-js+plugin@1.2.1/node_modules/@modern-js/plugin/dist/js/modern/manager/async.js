function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { runWithContainer, createContainer } from 'farrow-pipeline';
import { generateRunner, hasOwnProperty, DEFAULT_OPTIONS } from "./sync";
import { useRunner } from "./runner"; // eslint-disable-next-line @typescript-eslint/no-invalid-void-type

const ASYNC_PLUGIN_SYMBOL = 'ASYNC_PLUGIN_SYMBOL';
export const createAsyncManager = processes => {
  let index = 0;

  const createPlugin = (initializer, options = {}) => _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_OPTIONS), {}, {
    name: `No.${index++} plugin`
  }, options), {}, {
    ASYNC_PLUGIN_SYMBOL,
    initializer
  });

  const isPlugin = input => hasOwnProperty(input, ASYNC_PLUGIN_SYMBOL) && input[ASYNC_PLUGIN_SYMBOL] === ASYNC_PLUGIN_SYMBOL;

  const registe = extraProcesses => {
    // eslint-disable-next-line no-param-reassign
    processes = _objectSpread(_objectSpread({}, extraProcesses), processes);
  };

  const clone = () => {
    let plugins = [];

    const usePlugin = (...input) => {
      for (const plugin of input) {
        if (isPlugin(plugin)) {
          if (!includeAsyncPlugin(plugins, plugin)) {
            plugins.push(_objectSpread(_objectSpread({}, plugin), {}, {
              index: plugins.length
            }));
          }
        } else {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          console.warn(`Unknown plugin: ${plugin.name}`);
        }
      }

      return manager;
    };

    const clear = () => {
      plugins = [];
    };

    const currentContainer = createContainer();

    const init = async options => {
      const container = (options === null || options === void 0 ? void 0 : options.container) || currentContainer;
      const sortedPlugins = sortAsyncPlugins(plugins);
      checkAsyncPlugins(sortedPlugins);
      const hooksList = await Promise.all(sortedPlugins.map(plugin => runWithContainer(() => plugin.initializer(), container)));
      return generateRunner(hooksList, container, processes);
    };

    const run = (cb, options) => {
      const container = (options === null || options === void 0 ? void 0 : options.container) || currentContainer;
      return runWithContainer(cb, container);
    };

    const manager = {
      createPlugin,
      isPlugin,
      usePlugin,
      init,
      run,
      clear,
      clone,
      registe,
      useRunner
    };
    return manager;
  };

  return clone();
};

const includeAsyncPlugin = (plugins, input) => {
  for (const plugin of plugins) {
    if (plugin.name === input.name) {
      return true;
    }
  }

  return false;
};

const sortAsyncPlugins = input => {
  let plugins = input.slice();

  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];

    for (const pre of plugin.pre) {
      for (let j = i + 1; j < plugins.length; j++) {
        if (plugins[j].name === pre) {
          plugins = [...plugins.slice(0, i), plugins[j], ...plugins.slice(i, j), ...plugins.slice(j + 1, plugins.length)];
        }
      }
    }

    for (const post of plugin.post) {
      for (let j = 0; j < i; j++) {
        if (plugins[j].name === post) {
          plugins = [...plugins.slice(0, j), ...plugins.slice(j + 1, i + 1), plugins[j], ...plugins.slice(i + 1, plugins.length)];
        }
      }
    }
  }

  return plugins;
};

const checkAsyncPlugins = plugins => {
  for (const origin of plugins) {
    for (const rival of origin.rivals) {
      for (const plugin of plugins) {
        if (rival === plugin.name) {
          throw new Error(`${origin.name} has rival ${plugin.name}`);
        }
      }
    }

    for (const required of origin.required) {
      if (!plugins.some(plugin => plugin.name === required)) {
        throw new Error(`The plugin: ${required} is required when plugin: ${origin.name} is exist.`);
      }
    }
  }
};