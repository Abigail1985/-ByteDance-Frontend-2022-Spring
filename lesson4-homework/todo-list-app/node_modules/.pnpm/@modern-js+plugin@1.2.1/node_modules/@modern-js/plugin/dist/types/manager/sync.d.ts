import { Middleware, Pipeline, AsyncPipeline, MaybeAsync, Container } from 'farrow-pipeline';
import { Waterfall, Brook, AsyncWaterfall, AsyncBrook } from '../waterfall';
import { Worker, Workflow, AsyncWorker, AsyncWorkflow, ParallelWorkflow } from '../workflow';
export declare type Initializer<O> = () => O | void;
declare const SYNC_PLUGIN_SYMBOL = "SYNC_PLUGIN_SYMBOL";
export declare type Plugin<O> = {
  initializer: Initializer<O>;
  SYNC_PLUGIN_SYMBOL: typeof SYNC_PLUGIN_SYMBOL;
} & Required<PluginOptions>;
export declare type IndexPlugin<O> = Plugin<O> & {
  index: number;
};
export declare type Plugins<O> = Plugin<O>[];
export declare type IndexPlugins<O> = IndexPlugin<O>[];
export declare type PluginOptions = {
  name?: string;
  pre?: string[];
  post?: string[];
  rivals?: string[];
  required?: string[];
};
export declare type Progress = Waterfall<any> | AsyncWaterfall<any> | Workflow<any, any> | AsyncWorkflow<any, any> | ParallelWorkflow<any> | Pipeline<any, any> | AsyncPipeline<any, any>;
export declare type Progress2Thread<P extends Progress> = P extends Workflow<infer I, infer O> ? Worker<I, O> : P extends AsyncWorkflow<infer I, infer O> ? AsyncWorker<I, O> : P extends ParallelWorkflow<infer I, infer O> ? AsyncWorker<I, O> : P extends Waterfall<infer I> ? Brook<I> : P extends AsyncWaterfall<infer I> ? AsyncBrook<I> : P extends Pipeline<infer I, infer O> ? Middleware<I, O> : P extends AsyncPipeline<infer I, infer O> ? Middleware<I, MaybeAsync<O>> : never;
export declare type ProgressRecord = Record<string, Progress>;
export declare type Progresses2Threads<PS extends ProgressRecord | void> = { [K in keyof PS]: PS[K] extends Progress ? Progress2Thread<PS[K]> : PS[K] extends void ? void : never };
export declare type RunnerFromProgress<P extends Progress> = P extends Waterfall<infer I> ? Waterfall<I>['run'] : P extends AsyncWaterfall<infer I> ? AsyncWaterfall<I>['run'] : P extends Workflow<infer I, infer O> ? Workflow<I, O>['run'] : P extends AsyncWorkflow<infer I, infer O> ? AsyncWorkflow<I, O>['run'] : P extends ParallelWorkflow<infer I, infer O> ? ParallelWorkflow<I, O>['run'] : P extends Pipeline<infer I, infer O> ? Pipeline<I, O>['run'] : P extends AsyncPipeline<infer I, infer O> ? AsyncPipeline<I, O>['run'] : never;
export declare type Progresses2Runners<PS extends ProgressRecord | void> = { [K in keyof PS]: PS[K] extends Progress ? RunnerFromProgress<PS[K]> : PS[K] extends void ? void : never };
export declare type ClearDraftProgress<I extends Record<string, any>> = { [K in keyof I]: I[K] extends Progress ? I[K] : never };
export declare type PluginFromManager<M extends Manager<any, any>> = M extends Manager<infer EP, infer PR> ? Plugin<Partial<Progresses2Threads<PR & ClearDraftProgress<EP>>>> : never;
export declare type InitOptions = {
  container?: Container;
};
export declare type Manager<EP extends Record<string, any>, PR extends ProgressRecord | void = void> = {
  createPlugin: (initializer: Initializer<Partial<Progresses2Threads<PR & ClearDraftProgress<EP>>>>, options?: PluginOptions) => Plugin<Partial<Progresses2Threads<PR & ClearDraftProgress<EP>>>>;
  isPlugin: (input: Record<string, unknown>) => input is Plugin<Partial<Progresses2Threads<PR & ClearDraftProgress<EP>>>>;
  usePlugin: (...input: Plugins<Partial<Progresses2Threads<PR & ClearDraftProgress<EP>>>>) => Manager<EP, PR>;
  init: (options?: InitOptions) => Progresses2Runners<PR & ClearDraftProgress<EP>>;
  run: <O>(cb: () => O, options?: InitOptions) => O;
  registe: (newShape: Partial<EP>) => void;
  clear: () => void;
  clone: () => Manager<EP, PR>;
  useRunner: () => Progresses2Runners<PR & ClearDraftProgress<EP>>;
};
export declare const DEFAULT_OPTIONS: Required<PluginOptions>;
export declare const createManager: <EP extends Record<string, any> = {}, PR extends void | ProgressRecord = void>(processes?: PR | undefined) => Manager<EP, PR>;
export declare const generateRunner: <EP extends Record<string, any> = {}, PR extends void | ProgressRecord = void>(hooksList: (void | Partial<Progresses2Threads<PR & ClearDraftProgress<EP>>>)[], container: Container, processes?: PR | undefined) => Progresses2Runners<PR & ClearDraftProgress<EP>>;
export declare const cloneProgress: (progress: Progress) => Progress;
export declare const cloneProgressRecord: <PR extends void | ProgressRecord>(record: PR) => PR;
export declare const hasOwnProperty: <X extends Record<string, unknown>, Y extends PropertyKey>(obj: X, prop: Y) => obj is X & Record<Y, unknown>;
export {};