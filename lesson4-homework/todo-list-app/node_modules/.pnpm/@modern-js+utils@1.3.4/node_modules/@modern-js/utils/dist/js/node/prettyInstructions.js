"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prettyInstructions = exports.isSingleEntry = void 0;

var _os = _interopRequireDefault(require("os"));

var _chalk = _interopRequireDefault(require("chalk"));

var _is = require("./is");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: remove hard code 'main'
const isSingleEntry = entrypoints => entrypoints.length === 1 && entrypoints[0].entryName === 'main';

exports.isSingleEntry = isSingleEntry;

const normalizeUrl = url => url.replace(/([^:]\/)\/+/g, '$1');

const getAddressUrls = (protocol = 'http', port) => {
  const interfaces = _os.default.networkInterfaces();

  const ipv4Interfaces = [];
  Object.keys(interfaces).forEach(key => {
    interfaces[key].forEach(detail => {
      if (detail.family === 'IPv4') {
        ipv4Interfaces.push(detail);
      }
    });
  });
  return ipv4Interfaces.reduce((memo, detail) => {
    let type = 'Network:  ';
    let url = `${protocol}://${detail.address}:${port}`;

    if (detail.address.includes(`localhost`)) {
      type = 'Local:  ';
      url = `${protocol}://localhost:${port}`;
    }

    memo.push({
      type,
      url
    });
    return memo;
  }, []);
};

const prettyInstructions = (appContext, config) => {
  const {
    entrypoints,
    serverRoutes,
    port,
    existSrc,
    checkedEntries
  } = appContext;
  const urls = getAddressUrls(config.dev.https && (0, _is.isDev)() ? 'https' : 'http', port);
  const routes = existSrc ? serverRoutes.filter(route => route.entryName) : serverRoutes;
  let message = 'App running at:\n\n';

  if (isSingleEntry(entrypoints) || !existSrc) {
    message += urls.map(({
      type,
      url
    }) => `  ${_chalk.default.bold(`> ${type.padEnd(10)}`)}${_chalk.default.cyanBright(normalizeUrl(`${url}/${routes[0].urlPath}`))}\n`).join('');
  } else {
    const maxNameLength = Math.max(...routes.map(r => r.entryName.length));
    urls.forEach(({
      type,
      url
    }) => {
      message += `  ${_chalk.default.bold(`> ${type}`)}\n`;
      routes.forEach(({
        entryName,
        urlPath,
        isSSR
      }) => {
        if (!checkedEntries.includes(entryName)) {
          return;
        }

        message += `    ${_chalk.default.yellowBright(isSSR ? 'λ' : '○')}  ${_chalk.default.yellowBright(entryName.padEnd(maxNameLength + 8))}${_chalk.default.cyanBright(normalizeUrl(`${url}/${urlPath}`))}\n`;
      });
    });
    message += '\n';
    message += _chalk.default.cyanBright('  λ (Server) server-side renders at runtime\n');
    message += _chalk.default.cyanBright('  ○ (Static) client-side rendered as static HTML\n');
  }

  return message;
};

exports.prettyInstructions = prettyInstructions;