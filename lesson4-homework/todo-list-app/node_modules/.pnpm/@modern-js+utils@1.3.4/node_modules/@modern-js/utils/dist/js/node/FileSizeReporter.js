/* eslint-disable eslint-comments/no-unlimited-disable */

/* eslint-disable */

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/facebook/create-react-app/blob/master/LICENSE
 */
// Modified by Chao Xu (xuchaobei)
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.measureFileSizesBeforeBuild = measureFileSizesBeforeBuild;
exports.printFileSizesAfterBuild = printFileSizesAfterBuild;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _filesize = _interopRequireDefault(require("filesize"));

var _recursiveReaddir = _interopRequireDefault(require("recursive-readdir"));

var _stripAnsi = _interopRequireDefault(require("strip-ansi"));

var _gzipSize = _interopRequireDefault(require("gzip-size"));

var _logger = require("./logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function canReadAsset(asset) {
  return /\.(js|css)$/.test(asset) && !/service-worker\.js/.test(asset) && !/precache-manifest\.[0-9a-f]+\.js/.test(asset);
} // Prints a detailed summary of build files.


function printFileSizesAfterBuild(webpackStats, previousSizeMap, buildFolder, maxBundleGzipSize, maxChunkGzipSize) {
  var root = previousSizeMap.root;
  var sizes = previousSizeMap.sizes;
  var assets = (webpackStats.stats || [webpackStats]).map(stats => stats.toJson({
    all: false,
    assets: true
  }).assets.filter(asset => canReadAsset(asset.name)).map(asset => {
    var fileContents = _fs.default.readFileSync(_path.default.join(root, asset.name));

    var size = fileContents.length;

    var gzippedSize = _gzipSize.default.sync(fileContents);

    var [previousSize, previousGzipSize] = sizes[removeFileNameHash(root, asset.name)] || [];
    var sizeDifference = getDifferenceLabel(size, previousSize);
    var gzipSizeDifference = getDifferenceLabel(gzippedSize, previousGzipSize);
    return {
      folder: _path.default.join(_path.default.basename(buildFolder), _path.default.dirname(asset.name)),
      name: _path.default.basename(asset.name),
      gzippedSize: gzippedSize,
      sizeLabel: (0, _filesize.default)(size) + (sizeDifference ? ' (' + sizeDifference + ')' : ''),
      gzipSizeLabel: (0, _filesize.default)(gzippedSize) + (gzipSizeDifference ? ' (' + gzipSizeDifference + ')' : '')
    };
  })).reduce((single, all) => all.concat(single), []);
  assets.sort((a, b) => b.size - a.size);
  var longestSizeLabelLength = Math.max.apply(null, assets.map(a => (0, _stripAnsi.default)(a.sizeLabel).length));
  var longestFileNameLength = Math.max.apply(null, assets.map(a => (0, _stripAnsi.default)(a.folder + _path.default.sep + a.name).length));
  printFileSizesHeader(longestFileNameLength, longestSizeLabelLength);
  var suggestBundleSplitting = false;
  assets.forEach(asset => {
    var {
      folder,
      name,
      sizeLabel,
      gzipSizeLabel,
      gzippedSize
    } = asset;
    var fileNameLength = (0, _stripAnsi.default)(folder + _path.default.sep + name).length;
    var sizeLength = (0, _stripAnsi.default)(sizeLabel).length;

    if (sizeLength < longestSizeLabelLength) {
      var rightPadding = ' '.repeat(longestSizeLabelLength - sizeLength);
      sizeLabel += rightPadding;
    }

    var fileNameLabel = _chalk.default.dim(asset.folder + _path.default.sep) + _chalk.default.cyan(asset.name);

    if (fileNameLength < longestFileNameLength) {
      var rightPadding = ' '.repeat(longestFileNameLength - fileNameLength);
      fileNameLabel += rightPadding;
    }

    var isMainBundle = asset.name.indexOf('main.') === 0;
    var maxRecommendedSize = isMainBundle ? maxBundleGzipSize : maxChunkGzipSize;
    var isLarge = maxRecommendedSize && gzippedSize > maxRecommendedSize;

    if (isLarge && _path.default.extname(asset.name) === '.js') {
      suggestBundleSplitting = true;
    }

    _logger.logger.log('  ' + fileNameLabel + '    ' + sizeLabel + '    ' + (isLarge ? _chalk.default.yellow(gzipSizeLabel) : gzipSizeLabel));
  });

  if (suggestBundleSplitting) {
    _logger.logger.log();

    _logger.logger.warn('The bundle size is significantly larger than recommended.');
  }
}

function printFileSizesHeader(longestFileNameLength, longestSizeLabelLength) {
  const longestLengths = [longestFileNameLength, longestSizeLabelLength];
  const headerRow = ['File', 'Size', 'Gzipped'].reduce((prev, cur, index) => {
    const length = longestLengths[index];
    let curLabel = cur;

    if (length) {
      curLabel = cur.length < length ? cur + ' '.repeat(length - cur.length) : cur;
    }

    return prev + curLabel + '    ';
  }, '  ');

  _logger.logger.log(_chalk.default.bold(_chalk.default.blue(headerRow)));
}

function removeFileNameHash(buildFolder, fileName) {
  return fileName.replace(buildFolder, '').replace(/\\/g, '/').replace(/\/?(.*)(\.[0-9a-f]+)(\.chunk)?(\.js|\.css)/, (match, p1, p2, p3, p4) => p1 + p4);
} // Input: 1024, 2048
// Output: "(+1 KB)"


function getDifferenceLabel(currentSize, previousSize) {
  var FIFTY_KILOBYTES = 1024 * 50;
  var difference = currentSize - previousSize;
  var fileSize = !Number.isNaN(difference) ? (0, _filesize.default)(difference) : 0;

  if (difference >= FIFTY_KILOBYTES) {
    return _chalk.default.red('+' + fileSize);
  } else if (difference < FIFTY_KILOBYTES && difference > 0) {
    return _chalk.default.yellow('+' + fileSize);
  } else if (difference < 0) {
    return _chalk.default.green(fileSize);
  } else {
    return '';
  }
}

function measureFileSizesBeforeBuild(buildFolder) {
  return new Promise(resolve => {
    (0, _recursiveReaddir.default)(buildFolder, (err, fileNames) => {
      var sizes;

      if (!err && fileNames) {
        sizes = fileNames.filter(canReadAsset).reduce((memo, fileName) => {
          var contents = _fs.default.readFileSync(fileName);

          var key = removeFileNameHash(buildFolder, fileName); // save both the original size and gzip size

          memo[key] = [contents.length, _gzipSize.default.sync(contents)];
          return memo;
        }, {});
      }

      resolve({
        root: buildFolder,
        sizes: sizes || {}
      });
    });
  });
}
/* eslint-enable */