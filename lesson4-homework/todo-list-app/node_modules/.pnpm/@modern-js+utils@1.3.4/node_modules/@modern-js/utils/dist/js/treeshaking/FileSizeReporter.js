/* eslint-disable eslint-comments/no-unlimited-disable */

/* eslint-disable */

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/facebook/create-react-app/blob/master/LICENSE
 */
// Modified by Chao Xu (xuchaobei)
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import filesize from 'filesize';
import recursive from 'recursive-readdir';
import stripAnsi from 'strip-ansi';
import gzipSize from 'gzip-size';
import { logger } from "./logger";

function canReadAsset(asset) {
  return /\.(js|css)$/.test(asset) && !/service-worker\.js/.test(asset) && !/precache-manifest\.[0-9a-f]+\.js/.test(asset);
} // Prints a detailed summary of build files.


function printFileSizesAfterBuild(webpackStats, previousSizeMap, buildFolder, maxBundleGzipSize, maxChunkGzipSize) {
  var root = previousSizeMap.root;
  var sizes = previousSizeMap.sizes;
  var assets = (webpackStats.stats || [webpackStats]).map(function (stats) {
    return stats.toJson({
      all: false,
      assets: true
    }).assets.filter(function (asset) {
      return canReadAsset(asset.name);
    }).map(function (asset) {
      var fileContents = fs.readFileSync(path.join(root, asset.name));
      var size = fileContents.length;
      var gzippedSize = gzipSize.sync(fileContents);

      var _ref = sizes[removeFileNameHash(root, asset.name)] || [],
          _ref2 = _slicedToArray(_ref, 2),
          previousSize = _ref2[0],
          previousGzipSize = _ref2[1];

      var sizeDifference = getDifferenceLabel(size, previousSize);
      var gzipSizeDifference = getDifferenceLabel(gzippedSize, previousGzipSize);
      return {
        folder: path.join(path.basename(buildFolder), path.dirname(asset.name)),
        name: path.basename(asset.name),
        gzippedSize: gzippedSize,
        sizeLabel: filesize(size) + (sizeDifference ? ' (' + sizeDifference + ')' : ''),
        gzipSizeLabel: filesize(gzippedSize) + (gzipSizeDifference ? ' (' + gzipSizeDifference + ')' : '')
      };
    });
  }).reduce(function (single, all) {
    return all.concat(single);
  }, []);
  assets.sort(function (a, b) {
    return b.size - a.size;
  });
  var longestSizeLabelLength = Math.max.apply(null, assets.map(function (a) {
    return stripAnsi(a.sizeLabel).length;
  }));
  var longestFileNameLength = Math.max.apply(null, assets.map(function (a) {
    return stripAnsi(a.folder + path.sep + a.name).length;
  }));
  printFileSizesHeader(longestFileNameLength, longestSizeLabelLength);
  var suggestBundleSplitting = false;
  assets.forEach(function (asset) {
    var folder = asset.folder,
        name = asset.name,
        sizeLabel = asset.sizeLabel,
        gzipSizeLabel = asset.gzipSizeLabel,
        gzippedSize = asset.gzippedSize;
    var fileNameLength = stripAnsi(folder + path.sep + name).length;
    var sizeLength = stripAnsi(sizeLabel).length;

    if (sizeLength < longestSizeLabelLength) {
      var rightPadding = ' '.repeat(longestSizeLabelLength - sizeLength);
      sizeLabel += rightPadding;
    }

    var fileNameLabel = chalk.dim(asset.folder + path.sep) + chalk.cyan(asset.name);

    if (fileNameLength < longestFileNameLength) {
      var rightPadding = ' '.repeat(longestFileNameLength - fileNameLength);
      fileNameLabel += rightPadding;
    }

    var isMainBundle = asset.name.indexOf('main.') === 0;
    var maxRecommendedSize = isMainBundle ? maxBundleGzipSize : maxChunkGzipSize;
    var isLarge = maxRecommendedSize && gzippedSize > maxRecommendedSize;

    if (isLarge && path.extname(asset.name) === '.js') {
      suggestBundleSplitting = true;
    }

    logger.log('  ' + fileNameLabel + '    ' + sizeLabel + '    ' + (isLarge ? chalk.yellow(gzipSizeLabel) : gzipSizeLabel));
  });

  if (suggestBundleSplitting) {
    logger.log();
    logger.warn('The bundle size is significantly larger than recommended.');
  }
}

function printFileSizesHeader(longestFileNameLength, longestSizeLabelLength) {
  var longestLengths = [longestFileNameLength, longestSizeLabelLength];
  var headerRow = ['File', 'Size', 'Gzipped'].reduce(function (prev, cur, index) {
    var length = longestLengths[index];
    var curLabel = cur;

    if (length) {
      curLabel = cur.length < length ? cur + ' '.repeat(length - cur.length) : cur;
    }

    return prev + curLabel + '    ';
  }, '  ');
  logger.log(chalk.bold(chalk.blue(headerRow)));
}

function removeFileNameHash(buildFolder, fileName) {
  return fileName.replace(buildFolder, '').replace(/\\/g, '/').replace(/\/?(.*)(\.[0-9a-f]+)(\.chunk)?(\.js|\.css)/, function (match, p1, p2, p3, p4) {
    return p1 + p4;
  });
} // Input: 1024, 2048
// Output: "(+1 KB)"


function getDifferenceLabel(currentSize, previousSize) {
  var FIFTY_KILOBYTES = 1024 * 50;
  var difference = currentSize - previousSize;
  var fileSize = !Number.isNaN(difference) ? filesize(difference) : 0;

  if (difference >= FIFTY_KILOBYTES) {
    return chalk.red('+' + fileSize);
  } else if (difference < FIFTY_KILOBYTES && difference > 0) {
    return chalk.yellow('+' + fileSize);
  } else if (difference < 0) {
    return chalk.green(fileSize);
  } else {
    return '';
  }
}

function measureFileSizesBeforeBuild(buildFolder) {
  return new Promise(function (resolve) {
    recursive(buildFolder, function (err, fileNames) {
      var sizes;

      if (!err && fileNames) {
        sizes = fileNames.filter(canReadAsset).reduce(function (memo, fileName) {
          var contents = fs.readFileSync(fileName);
          var key = removeFileNameHash(buildFolder, fileName); // save both the original size and gzip size

          memo[key] = [contents.length, gzipSize.sync(contents)];
          return memo;
        }, {});
      }

      resolve({
        root: buildFolder,
        sizes: sizes || {}
      });
    });
  });
}

export { measureFileSizesBeforeBuild, printFileSizesAfterBuild };
/* eslint-enable */