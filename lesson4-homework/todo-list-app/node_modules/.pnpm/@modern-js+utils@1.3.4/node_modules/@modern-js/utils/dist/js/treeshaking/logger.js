function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

import chalk from 'chalk';
var grey = chalk.grey,
    underline = chalk.underline;
var LOG_TYPES = {
  error: {
    color: 'red',
    label: 'error',
    level: 'error'
  },
  info: {
    color: 'blue',
    label: 'info',
    level: 'info'
  },
  warn: {
    color: 'yellow',
    label: 'warning',
    level: 'warn'
  },
  debug: {
    color: 'red',
    label: 'debug',
    level: 'debug'
  },
  log: {
    level: 'info'
  }
};
var DEFAULT_CONFIG = {
  displayLabel: true,
  underlineLabel: true,
  uppercaseLabel: false
};

var Logger = /*#__PURE__*/function () {
  function Logger() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Logger);

    this.logCount = 200;
    this.history = {};
    this.config = void 0;
    this.types = void 0;
    this.longestLabel = void 0;
    this.config = _objectSpread(_objectSpread({}, DEFAULT_CONFIG), options.config || {});
    this.types = _objectSpread(_objectSpread({}, LOG_TYPES), options.types || {});
    this.longestLabel = this.getLongestLabel();
    Object.keys(this.types).forEach(function (type) {
      _this[type] = _this._log.bind(_this, type);
    });
  }

  _createClass(Logger, [{
    key: "retainLog",
    value: function retainLog(type, message) {
      if (!this.history[type]) {
        this.history[type] = [];
      }

      this.history[type].push(message);

      while (this.history[type].length > this.logCount) {
        this.history[type].shift();
      }
    } // eslint-disable-next-line max-statements

  }, {
    key: "_log",
    value: function _log(type, message) {
      if (message === undefined) {
        // eslint-disable-next-line no-console
        console.log();
        return;
      }

      var label = '';
      var text = '';
      var logType = this.types[type];

      if (this.config.displayLabel && logType.label) {
        label = this.config.uppercaseLabel ? logType.label.toUpperCase() : logType.label;

        if (this.config.underlineLabel) {
          label = underline(label).padEnd(this.longestUnderlinedLabel.length + 1);
        } else {
          label = label.padEnd(this.longestLabel.length + 1);
        }

        label = logType.color ? chalk[logType.color](label) : label;
      }

      if (message instanceof Error) {
        if (message.stack) {
          var _message$stack$split = message.stack.split('\n'),
              _message$stack$split2 = _toArray(_message$stack$split),
              name = _message$stack$split2[0],
              rest = _message$stack$split2.slice(1);

          text = "".concat(name, "\n").concat(grey(rest.join('\n')));
        } else {
          text = message.message;
        }
      } else {
        text = "".concat(message);
      } // only retain logs of warn/error level


      if (logType.level === 'warn' || logType.level === 'error') {
        // retain log text without label
        this.retainLog(type, text);
      }

      var log = label.length > 0 ? "".concat(label, "  ").concat(text) : text; // eslint-disable-next-line no-console

      console.log(log);
    }
  }, {
    key: "getLongestLabel",
    value: function getLongestLabel() {
      var _this2 = this;

      var longestLabel = '';
      Object.keys(this.types).forEach(function (type) {
        var _this2$types$type$lab = _this2.types[type].label,
            label = _this2$types$type$lab === void 0 ? '' : _this2$types$type$lab;

        if (label.length > longestLabel.length) {
          longestLabel = label;
        }
      });
      return longestLabel;
    }
  }, {
    key: "longestUnderlinedLabel",
    get: function get() {
      return underline(this.longestLabel);
    }
  }, {
    key: "getRetainedLogs",
    value: function getRetainedLogs(type) {
      return this.history[type] || [];
    }
  }, {
    key: "clearRetainedLogs",
    value: function clearRetainedLogs(type) {
      if (type) {
        if (this.history[type]) {
          this.history[type] = [];
        }
      } else {
        this.history = {};
      }
    }
  }]);

  return Logger;
}();

var logger = new Logger();
logger.Logger = Logger;
export { logger };