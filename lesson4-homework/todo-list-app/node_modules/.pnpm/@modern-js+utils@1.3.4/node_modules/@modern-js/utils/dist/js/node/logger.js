"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const {
  grey,
  underline
} = _chalk.default;
const LOG_TYPES = {
  error: {
    color: 'red',
    label: 'error',
    level: 'error'
  },
  info: {
    color: 'blue',
    label: 'info',
    level: 'info'
  },
  warn: {
    color: 'yellow',
    label: 'warning',
    level: 'warn'
  },
  debug: {
    color: 'red',
    label: 'debug',
    level: 'debug'
  },
  log: {
    level: 'info'
  }
};
const DEFAULT_CONFIG = {
  displayLabel: true,
  underlineLabel: true,
  uppercaseLabel: false
};

class Logger {
  constructor(options = {}) {
    this.logCount = 200;
    this.history = {};
    this.config = void 0;
    this.types = void 0;
    this.longestLabel = void 0;
    this.config = _objectSpread(_objectSpread({}, DEFAULT_CONFIG), options.config || {});
    this.types = _objectSpread(_objectSpread({}, LOG_TYPES), options.types || {});
    this.longestLabel = this.getLongestLabel();
    Object.keys(this.types).forEach(type => {
      this[type] = this._log.bind(this, type);
    });
  }

  retainLog(type, message) {
    if (!this.history[type]) {
      this.history[type] = [];
    }

    this.history[type].push(message);

    while (this.history[type].length > this.logCount) {
      this.history[type].shift();
    }
  } // eslint-disable-next-line max-statements


  _log(type, message) {
    if (message === undefined) {
      // eslint-disable-next-line no-console
      console.log();
      return;
    }

    let label = '';
    let text = '';
    const logType = this.types[type];

    if (this.config.displayLabel && logType.label) {
      label = this.config.uppercaseLabel ? logType.label.toUpperCase() : logType.label;

      if (this.config.underlineLabel) {
        label = underline(label).padEnd(this.longestUnderlinedLabel.length + 1);
      } else {
        label = label.padEnd(this.longestLabel.length + 1);
      }

      label = logType.color ? _chalk.default[logType.color](label) : label;
    }

    if (message instanceof Error) {
      if (message.stack) {
        const [name, ...rest] = message.stack.split('\n');
        text = `${name}\n${grey(rest.join('\n'))}`;
      } else {
        text = message.message;
      }
    } else {
      text = `${message}`;
    } // only retain logs of warn/error level


    if (logType.level === 'warn' || logType.level === 'error') {
      // retain log text without label
      this.retainLog(type, text);
    }

    const log = label.length > 0 ? `${label}  ${text}` : text; // eslint-disable-next-line no-console

    console.log(log);
  }

  getLongestLabel() {
    let longestLabel = '';
    Object.keys(this.types).forEach(type => {
      const {
        label = ''
      } = this.types[type];

      if (label.length > longestLabel.length) {
        longestLabel = label;
      }
    });
    return longestLabel;
  }

  get longestUnderlinedLabel() {
    return underline(this.longestLabel);
  }

  getRetainedLogs(type) {
    return this.history[type] || [];
  }

  clearRetainedLogs(type) {
    if (type) {
      if (this.history[type]) {
        this.history[type] = [];
      }
    } else {
      this.history = {};
    }
  }

}

const logger = new Logger();
exports.logger = logger;
logger.Logger = Logger;