function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import os from 'os';
import chalk from 'chalk';
import { isDev } from "./is"; // TODO: type

// TODO: remove hard code 'main'
export var isSingleEntry = function isSingleEntry(entrypoints) {
  return entrypoints.length === 1 && entrypoints[0].entryName === 'main';
};

var normalizeUrl = function normalizeUrl(url) {
  return url.replace(/([^:]\/)\/+/g, '$1');
};

var getAddressUrls = function getAddressUrls() {
  var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';
  var port = arguments.length > 1 ? arguments[1] : undefined;
  var interfaces = os.networkInterfaces();
  var ipv4Interfaces = [];
  Object.keys(interfaces).forEach(function (key) {
    interfaces[key].forEach(function (detail) {
      if (detail.family === 'IPv4') {
        ipv4Interfaces.push(detail);
      }
    });
  });
  return ipv4Interfaces.reduce(function (memo, detail) {
    var type = 'Network:  ';
    var url = "".concat(protocol, "://").concat(detail.address, ":").concat(port);

    if (detail.address.includes("localhost")) {
      type = 'Local:  ';
      url = "".concat(protocol, "://localhost:").concat(port);
    }

    memo.push({
      type: type,
      url: url
    });
    return memo;
  }, []);
};

export var prettyInstructions = function prettyInstructions(appContext, config) {
  var _ref = appContext,
      entrypoints = _ref.entrypoints,
      serverRoutes = _ref.serverRoutes,
      port = _ref.port,
      existSrc = _ref.existSrc,
      checkedEntries = _ref.checkedEntries;
  var urls = getAddressUrls(config.dev.https && isDev() ? 'https' : 'http', port);
  var routes = existSrc ? serverRoutes.filter(function (route) {
    return route.entryName;
  }) : serverRoutes;
  var message = 'App running at:\n\n';

  if (isSingleEntry(entrypoints) || !existSrc) {
    message += urls.map(function (_ref2) {
      var type = _ref2.type,
          url = _ref2.url;
      return "  ".concat(chalk.bold("> ".concat(type.padEnd(10)))).concat(chalk.cyanBright(normalizeUrl("".concat(url, "/").concat(routes[0].urlPath))), "\n");
    }).join('');
  } else {
    var maxNameLength = Math.max.apply(Math, _toConsumableArray(routes.map(function (r) {
      return r.entryName.length;
    })));
    urls.forEach(function (_ref3) {
      var type = _ref3.type,
          url = _ref3.url;
      message += "  ".concat(chalk.bold("> ".concat(type)), "\n");
      routes.forEach(function (_ref4) {
        var entryName = _ref4.entryName,
            urlPath = _ref4.urlPath,
            isSSR = _ref4.isSSR;

        if (!checkedEntries.includes(entryName)) {
          return;
        }

        message += "    ".concat(chalk.yellowBright(isSSR ? 'λ' : '○'), "  ").concat(chalk.yellowBright(entryName.padEnd(maxNameLength + 8))).concat(chalk.cyanBright(normalizeUrl("".concat(url, "/").concat(urlPath))), "\n");
      });
    });
    message += '\n';
    message += chalk.cyanBright('  λ (Server) server-side renders at runtime\n');
    message += chalk.cyanBright('  ○ (Static) client-side rendered as static HTML\n');
  }

  return message;
};