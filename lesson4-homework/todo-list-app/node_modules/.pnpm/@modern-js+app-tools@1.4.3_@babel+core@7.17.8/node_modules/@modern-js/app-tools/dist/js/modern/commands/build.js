function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { webpack } from 'webpack';
import { WebpackConfigTarget, getWebpackConfig } from '@modern-js/webpack';
import { useAppContext, useResolvedConfigContext, mountHook, ResolvedConfigContext, manager } from '@modern-js/core';
import { formatWebpackMessages, measureFileSizesBeforeBuild, printFileSizesAfterBuild, printBuildError, logger, isUseSSRBundle, emptyDir } from '@modern-js/utils';
import { generateRoutes } from "../utils/routes"; // These sizes are pretty large. We'll warn for bundles exceeding them.

const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;
// eslint-disable-next-line max-statements
export const build = async options => {
  /* eslint-disable react-hooks/rules-of-hooks */
  const resolvedConfig = useResolvedConfigContext();
  const appContext = useAppContext();
  const {
    existSrc
  } = appContext;
  /* eslint-enable react-hooks/rules-of-hooks */

  if (!existSrc) {
    const {
      distDirectory
    } = appContext;
    await emptyDir(distDirectory);
    await mountHook().beforeBuild({
      webpackConfigs: []
    });
    await generateRoutes(appContext);
    await mountHook().afterBuild();
    return;
  }

  const webpackBuild = async (webpackConfig, type) => {
    const compiler = webpack(webpackConfig);
    return new Promise((resolve, reject) => {
      let label = process.env.NODE_ENV || '';

      if (type && type !== 'legacy') {
        label += ` ${type}`;
      }

      logger.info(`Creating a ${label} build...`);
      compiler.run((err, stats) => {
        let messages;

        if (!err) {
          messages = formatWebpackMessages(stats.toJson({
            all: false,
            warnings: true,
            errors: true
          }));

          if (messages.errors.length === 0) {
            logger.info(`File sizes after ${label} build:\n`);
            printFileSizesAfterBuild(stats, previousFileSizes, distDirectory, WARN_AFTER_BUNDLE_GZIP_SIZE, WARN_AFTER_CHUNK_GZIP_SIZE);
            logger.log();
          }
        } // When using run or watch, call close and wait for it to finish before calling run or watch again.
        // Concurrent compilations will corrupt the output files.


        compiler.close(closeErr => {
          if (closeErr) {
            logger.error(closeErr);
          }

          if (err) {
            reject(err);
          } else {
            if (messages.errors.length) {
              reject(new Error(messages.errors.join('\n\n')));
              return;
            }

            resolve({
              warnings: messages.warnings
            });
          }
        });
      });
    });
  };

  manager.run(() => {
    ResolvedConfigContext.set(_objectSpread(_objectSpread({}, resolvedConfig), {}, {
      cliOptions: options
    }));
  });
  const {
    distDirectory
  } = appContext;
  const previousFileSizes = await measureFileSizesBeforeBuild(distDirectory);
  await emptyDir(distDirectory);
  const buildConfigs = [];
  buildConfigs.push({
    type: 'legacy',
    config: getWebpackConfig(WebpackConfigTarget.CLIENT)
  });

  if (resolvedConfig.output.enableModernMode) {
    buildConfigs.push({
      type: 'modern',
      config: getWebpackConfig(WebpackConfigTarget.MODERN)
    });
  }

  if (isUseSSRBundle(resolvedConfig)) {
    buildConfigs.push({
      type: 'ssr',
      config: getWebpackConfig(WebpackConfigTarget.NODE)
    });
  }

  await mountHook().beforeBuild({
    webpackConfigs: buildConfigs.map(({
      config
    }) => config)
  });

  for (const buildConfig of buildConfigs) {
    const {
      type: buildType,
      config
    } = buildConfig;

    try {
      await webpackBuild(config, buildType);
    } catch (error) {
      printBuildError(error); // eslint-disable-next-line no-process-exit

      process.exit(1);
    }
  }

  await generateRoutes(appContext);
  await mountHook().afterBuild();
};