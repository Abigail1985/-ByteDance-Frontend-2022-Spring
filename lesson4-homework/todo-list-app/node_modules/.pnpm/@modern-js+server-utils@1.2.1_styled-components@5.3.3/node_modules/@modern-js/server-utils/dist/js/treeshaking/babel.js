function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { getBabelChain } from '@modern-js/babel-preset-lib';
import { applyOptionsChain, fs, getAlias } from '@modern-js/utils';
import json5 from 'json5';
export * from '@babel/core';
export var readTsConfig = function readTsConfig(tsconfigPath) {
  var noExistReturn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  // 如果不存在，则返回 noExistReturn
  if (!fs.existsSync(tsconfigPath)) {
    return noExistReturn;
  }

  var content = fs.readFileSync(tsconfigPath, 'utf-8');
  return json5.parse(content);
};
export var existTsConfigFile = function existTsConfigFile(tsconfigAbsolutePath) {
  var tsconfig = readTsConfig(tsconfigAbsolutePath);
  return Boolean(tsconfig);
};
export var getBabelConfig = function getBabelConfig(libPresetOption, syntaxOption) {
  var chain = getBabelChain(libPresetOption, syntaxOption);
  return _objectSpread({
    sourceType: 'unambiguous'
  }, chain.toJSON());
};
export var resolveBabelConfig = function resolveBabelConfig(appDirectory, modernConfig, option // FIXME: babel type can't pass type checking
) {
  var _modernConfig$source = modernConfig.source,
      envVars = _modernConfig$source.envVars,
      globalVars = _modernConfig$source.globalVars,
      _modernConfig$source$ = _modernConfig$source.jsxTransformRuntime,
      jsxTransformRuntime = _modernConfig$source$ === void 0 ? 'automatic' : _modernConfig$source$,
      userLodashOption = modernConfig.tools.lodash; // alias config

  var aliasConfig = getAlias(modernConfig.source.alias, _objectSpread({
    appDirectory: appDirectory
  }, option)); // lodash config

  var lodashOptions = applyOptionsChain({
    id: ['lodash', 'ramda']
  }, // TODO: 需要处理类型问题
  userLodashOption); // babel config

  var babelChain = getBabelChain({
    appDirectory: appDirectory,
    enableReactPreset: true,
    enableTypescriptPreset: true,
    alias: aliasConfig,
    envVars: envVars,
    globalVars: globalVars,
    lodashOptions: lodashOptions,
    jsxTransformRuntime: jsxTransformRuntime
  }, {
    type: option.type,
    syntax: option.syntax
  });
  var envOptions = babelChain.preset('@babel/preset-env').options();
  babelChain.preset('@babel/preset-env').use(require.resolve('@babel/preset-env'), [_objectSpread(_objectSpread({}, envOptions[0]), {}, {
    loose: true
  })]);
  babelChain.plugin('babel-plugin-transform-typescript-metadata').use(require.resolve('babel-plugin-transform-typescript-metadata'), []);
  babelChain.plugin('@babel/plugin-proposal-decorators').use(require.resolve('@babel/plugin-proposal-decorators'), [{
    legacy: true
  }]);
  babelChain.plugin('@babel/plugin-proposal-class-properties').use(require.resolve('@babel/plugin-proposal-class-properties'), [{
    loose: true
  }]);

  var internalBabelConfig = _objectSpread({}, babelChain.toJSON());

  var userBabelConfig = modernConfig.tools.babel;
  applyOptionsChain(internalBabelConfig, // TODO: 感觉 userBabelConfig 的类型应该是TransformOptions
  userBabelConfig, {
    chain: babelChain
  });
  return internalBabelConfig;
};