function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import fs from 'fs';
import path from 'path';
import { applyOptionsChain, isProd, isUseSSRBundle, SERVER_BUNDLE_DIRECTORY } from '@modern-js/utils';
import nodeExternals from 'webpack-node-externals';
import { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer';
import { mergeRegex } from "../utils/mergeRegex";
import { getSourceIncludes } from "../utils/getSourceIncludes";
import { JS_RESOLVE_EXTENSIONS } from "../utils/constants";
import { BaseWebpackConfig } from "./base";

class NodeWebpackConfig extends BaseWebpackConfig {
  get externalsAllowlist() {
    const includes = getSourceIncludes(this.appDirectory, this.options);
    return [name => {
      const ext = path.extname(name);
      return name.includes('@modern-js/') || ext !== '' && !JS_RESOLVE_EXTENSIONS.includes(ext);
    }, includes.length && mergeRegex(...includes)].filter(Boolean);
  }

  name() {
    this.chain.name('server');
  }

  devtool() {
    this.chain.devtool(false);
  }

  output() {
    super.output();
    this.chain.output.libraryTarget('commonjs2').filename(`${SERVER_BUNDLE_DIRECTORY}/[name].js`);
    this.chain.output.delete('chunkFilename');
  }

  optimization() {
    super.optimization();
    this.chain.optimization.minimize(false);
    this.chain.optimization.splitChunks(false).runtimeChunk(false);
  }

  loaders() {
    var _this$options$output, _this$options$output2, _this$options$tools;

    const loaders = super.loaders(); // css & css modules

    if (loaders.oneOfs.has('css')) {
      loaders.oneOf('css').uses.delete('mini-css-extract');
    }

    loaders.oneOf('css-modules').uses.delete('mini-css-extract').end().use('css').options({
      sourceMap: isProd() && !((_this$options$output = this.options.output) !== null && _this$options$output !== void 0 && _this$options$output.disableSourceMap),
      importLoaders: 1,
      modules: {
        localIdentName: this.options.output ? this.options.output.cssModuleLocalIdentName : '',
        exportLocalsConvention: 'camelCase',
        exportOnlyLocals: true
      }
    });
    const babelOptions = loaders.oneOf('js').use('babel').get('options');
    loaders.oneOf('js').use('babel').options(_objectSpread(_objectSpread({}, babelOptions), {}, {
      presets: [[require.resolve('@modern-js/babel-preset-app'), {
        metaName: this.appContext.metaName,
        appDirectory: this.appDirectory,
        target: 'server',
        useLegacyDecorators: !((_this$options$output2 = this.options.output) !== null && _this$options$output2 !== void 0 && _this$options$output2.enableLatestDecorators),
        useBuiltIns: false,
        chain: this.babelChain,
        styledComponents: applyOptionsChain({
          pure: true,
          displayName: true,
          ssr: isUseSSRBundle(this.options),
          transpileTemplateLiterals: true
        }, (_this$options$tools = this.options.tools) === null || _this$options$tools === void 0 ? void 0 : _this$options$tools.styledComponents)
      }]]
    })); // TODO: ts-loader

    return loaders;
  }

  plugins() {
    var _this$options$cliOpti;

    super.plugins();

    if ((_this$options$cliOpti = this.options.cliOptions) !== null && _this$options$cliOpti !== void 0 && _this$options$cliOpti.analyze) {
      this.chain.plugin('bundle-analyze').use(BundleAnalyzerPlugin, [{
        analyzerMode: 'static',
        openAnalyzer: false,
        reportFilename: 'report-ssr.html'
      }]);
    }
  }

  resolve() {
    super.resolve();

    for (const ext of ['.node.js', '.node.jsx', '.node.ts', '.node.tsx'].reverse()) {
      this.chain.resolve.extensions.prepend(ext);
    }

    this.chain.resolve.mainFields.clear().add('main');
  }

  config() {
    var _config$resolve, _config$resolve$modul;

    const config = super.config();
    config.target = 'node'; // dsiable sourcemap

    config.devtool = false; // prod bundle all dependencies

    if (isProd()) {
      config.externals = [];
      return config;
    }

    config.externals = config.externals || [];

    if (!Array.isArray(config.externals)) {
      config.externals = [config.externals].filter(Boolean);
    } // @modern-js/utils use typescript for peerDependency, but js project not depend it
    // if not externals, js ssr build error


    config.externals.push('typescript');
    (_config$resolve = config.resolve) === null || _config$resolve === void 0 ? void 0 : (_config$resolve$modul = _config$resolve.modules) === null || _config$resolve$modul === void 0 ? void 0 : _config$resolve$modul.forEach(dir => {
      if (fs.existsSync(dir)) {
        config.externals.push(nodeExternals({
          allowlist: this.externalsAllowlist,
          modulesDir: dir
        }));
      }
    });
    return config;
  }

}

export { NodeWebpackConfig };