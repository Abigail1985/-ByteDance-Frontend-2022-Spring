"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverseSchema = exports.patchSchema = void 0;

var _utils = require("@modern-js/utils");

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _source = require("./source");

var _output = require("./output");

var _server = require("./server");

var _deploy = require("./deploy");

var _tools = require("./tools");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _utils.createDebugger)('validate-schema');
const plugins = {
  type: 'array',
  additionalProperties: false
};
const dev = {
  type: 'object',
  properties: {
    assetPrefix: {
      type: ['boolean', 'string']
    },
    https: {
      type: 'boolean'
    }
  },
  additionalProperties: false
};

const patchSchema = pluginSchemas => {
  const finalSchema = (0, _lodash.default)({
    type: 'object',
    additionalProperties: false,
    properties: {
      source: _source.source,
      output: _output.output,
      server: _server.server,
      deploy: _deploy.deploy,
      plugins,
      dev,
      tools: _tools.tools
    }
  });

  const findTargetNode = props => {
    let node = finalSchema.properties;

    for (const prop of props) {
      node = node[prop];

      if (!node || !(0, _utils.isObject)(node)) {
        throw new Error(`add schema ${props.join('.')} error`);
      }

      node.properties = node.hasOwnProperty('properties') ? node.properties : {};
      node = node.properties;
    }

    return node;
  };

  const finalPluginSchemas = [];
  pluginSchemas.forEach(item => {
    if (Array.isArray(item)) {
      finalPluginSchemas.push(...item);
    } else {
      finalPluginSchemas.push(item);
    }
  });

  for (const {
    target,
    schema
  } of finalPluginSchemas) {
    if (!target) {
      throw new Error(`should return target property in plugin schema.`);
    }

    const props = target.split('.');
    const mountProperty = props.pop();
    const targetNode = findTargetNode(props);

    if (targetNode.hasOwnProperty(mountProperty)) {
      throw new Error(`${target} already exists in current validate schema`);
    }

    targetNode[mountProperty] = (0, _lodash.default)(schema);
  }

  debug(`final validate schema: %o`, finalSchema);
  return finalSchema;
};

exports.patchSchema = patchSchema;

const traverseSchema = schema => {
  const keys = [];

  const traverse = ({
    properties
  }, old = []) => {
    for (const key of Object.keys(properties)) {
      const current = [...old, key];

      if (properties[key].type === 'object' && properties[key].properties) {
        traverse(properties[key], current);
      } else {
        keys.push(current.join('.'));
      }
    }
  };

  traverse(schema);
  return keys;
};

exports.traverseSchema = traverseSchema;