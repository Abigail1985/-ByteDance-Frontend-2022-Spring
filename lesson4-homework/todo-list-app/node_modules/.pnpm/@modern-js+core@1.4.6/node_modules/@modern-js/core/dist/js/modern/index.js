function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import path from 'path';
import { compatRequire, pkgUp, ensureAbsolutePath, logger } from '@modern-js/utils';
import { createAsyncManager, createAsyncWorkflow, createParallelWorkflow, createAsyncWaterfall } from '@modern-js/plugin';
import { enable } from '@modern-js/plugin/node';
import { program } from "./utils/commander";
import { resolveConfig, loadUserConfig } from "./config";
import { loadPlugins } from "./loadPlugins";
import { AppContext, ConfigContext, initAppContext, ResolvedConfigContext, useAppContext, useConfigContext, useResolvedConfigContext } from "./context";
import { initWatcher } from "./initWatcher";
import { loadEnv } from "./loadEnv";
export * from "./config";
export * from '@modern-js/plugin';
export * from '@modern-js/plugin/node';
program.name('modern').usage('<command> [options]').version(process.env.MODERN_JS_VERSION || '0.1.0');
const hooksMap = {
  config: createParallelWorkflow(),
  resolvedConfig: createAsyncWaterfall(),
  validateSchema: createParallelWorkflow(),
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  prepare: createAsyncWorkflow(),
  commands: createAsyncWorkflow(),
  watchFiles: createParallelWorkflow(),
  fileChange: createAsyncWorkflow(),
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  beforeExit: createAsyncWorkflow(),
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  beforeRestart: createAsyncWorkflow()
};
export const manager = createAsyncManager(hooksMap);
export const {
  createPlugin,
  registe: registerHook,
  useRunner: mountHook
} = manager;
export const usePlugins = plugins => plugins.forEach(plugin => manager.usePlugin(compatRequire(require.resolve(plugin))));
export { AppContext, ResolvedConfigContext, useAppContext, useConfigContext, useResolvedConfigContext, ConfigContext };

const initAppDir = async cwd => {
  if (!cwd) {
    // eslint-disable-next-line no-param-reassign
    cwd = process.cwd();
  }

  const pkg = await pkgUp({
    cwd
  });

  if (!pkg) {
    throw new Error(`no package.json found in current work dir: ${cwd}`);
  }

  return path.dirname(pkg);
};

const createCli = () => {
  let hooksRunner;
  let isRestart = false;
  let restartWithExistingPort = 0;
  let restartOptions;

  const init = async (argv = [], options) => {
    var _options$options$meta, _options$options;

    enable();
    manager.clear();
    restartOptions = options;
    const appDirectory = await initAppDir();
    const metaName = (_options$options$meta = options === null || options === void 0 ? void 0 : (_options$options = options.options) === null || _options$options === void 0 ? void 0 : _options$options.metaName) !== null && _options$options$meta !== void 0 ? _options$options$meta : 'MODERN';
    loadEnv(appDirectory, process.env[`${metaName.toUpperCase()}_ENV`]);
    const loaded = await loadUserConfig(appDirectory, options === null || options === void 0 ? void 0 : options.configFile, options === null || options === void 0 ? void 0 : options.packageJsonConfig);
    const plugins = loadPlugins(appDirectory, loaded.config, {
      internalPlugins: options === null || options === void 0 ? void 0 : options.plugins,
      transformPlugin: options === null || options === void 0 ? void 0 : options.transformPlugin
    });
    plugins.forEach(plugin => plugin.cli && manager.usePlugin(plugin.cli));
    const appContext = initAppContext(appDirectory, plugins, loaded.filePath, options === null || options === void 0 ? void 0 : options.options);
    manager.run(() => {
      ConfigContext.set(loaded.config);
      AppContext.set(appContext);
    });
    hooksRunner = await manager.init();
    ['SIGINT', 'SIGTERM', 'unhandledRejection', 'uncaughtException'].forEach(event => {
      process.on(event, async err => {
        await hooksRunner.beforeExit();

        if (err instanceof Error) {
          logger.error(err.stack);
        }

        process.nextTick(() => {
          // eslint-disable-next-line no-process-exit
          process.exit(1);
        });
      });
    });
    const extraConfigs = await hooksRunner.config();
    const extraSchemas = await hooksRunner.validateSchema();
    const config = await resolveConfig(loaded, extraConfigs, extraSchemas, restartWithExistingPort, argv, options === null || options === void 0 ? void 0 : options.onSchemaError);
    const {
      resolved
    } = await hooksRunner.resolvedConfig({
      resolved: config
    }); // update context value

    manager.run(() => {
      ConfigContext.set(loaded.config);
      ResolvedConfigContext.set(resolved);
      AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
        port: resolved.server.port,
        distDirectory: ensureAbsolutePath(appDirectory, resolved.output.path)
      }));
    });
    await hooksRunner.prepare();
    return {
      loadedConfig: loaded,
      appContext,
      resolved
    };
  };

  async function run(argv, options) {
    const {
      loadedConfig,
      appContext,
      resolved
    } = await init(argv, options);
    await hooksRunner.commands({
      program
    });
    initWatcher(loadedConfig, appContext.appDirectory, resolved.source.configDir, hooksRunner, argv);
    manager.run(() => program.parse(process.argv));
  }

  async function restart() {
    var _AppContext$use$value, _AppContext$use$value2;

    isRestart = true;
    restartWithExistingPort = isRestart ? (_AppContext$use$value = (_AppContext$use$value2 = AppContext.use().value) === null || _AppContext$use$value2 === void 0 ? void 0 : _AppContext$use$value2.port) !== null && _AppContext$use$value !== void 0 ? _AppContext$use$value : 0 : 0;
    logger.info('Restart...\n');
    let hasGetError = false;
    const runner = manager.useRunner();
    await runner.beforeRestart();

    try {
      await init(process.argv.slice(2), restartOptions);
    } catch (err) {
      console.error(err);
      hasGetError = true;
    } finally {
      if (!hasGetError) {
        manager.run(() => program.parse(process.argv));
      }
    }
  }

  return {
    init,
    run,
    restart
  };
};

export const cli = createCli();
export { initAppDir, initAppContext };