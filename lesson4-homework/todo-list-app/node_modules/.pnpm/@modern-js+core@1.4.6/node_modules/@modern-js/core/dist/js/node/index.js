"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  manager: true,
  createPlugin: true,
  registerHook: true,
  mountHook: true,
  usePlugins: true,
  cli: true,
  initAppDir: true,
  AppContext: true,
  ConfigContext: true,
  initAppContext: true,
  ResolvedConfigContext: true,
  useAppContext: true,
  useConfigContext: true,
  useResolvedConfigContext: true
};
Object.defineProperty(exports, "AppContext", {
  enumerable: true,
  get: function () {
    return _context.AppContext;
  }
});
Object.defineProperty(exports, "ConfigContext", {
  enumerable: true,
  get: function () {
    return _context.ConfigContext;
  }
});
Object.defineProperty(exports, "ResolvedConfigContext", {
  enumerable: true,
  get: function () {
    return _context.ResolvedConfigContext;
  }
});
exports.createPlugin = exports.cli = void 0;
Object.defineProperty(exports, "initAppContext", {
  enumerable: true,
  get: function () {
    return _context.initAppContext;
  }
});
exports.registerHook = exports.mountHook = exports.manager = exports.initAppDir = void 0;
Object.defineProperty(exports, "useAppContext", {
  enumerable: true,
  get: function () {
    return _context.useAppContext;
  }
});
Object.defineProperty(exports, "useConfigContext", {
  enumerable: true,
  get: function () {
    return _context.useConfigContext;
  }
});
exports.usePlugins = void 0;
Object.defineProperty(exports, "useResolvedConfigContext", {
  enumerable: true,
  get: function () {
    return _context.useResolvedConfigContext;
  }
});

var _path = _interopRequireDefault(require("path"));

var _utils = require("@modern-js/utils");

var _plugin = require("@modern-js/plugin");

Object.keys(_plugin).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _plugin[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _plugin[key];
    }
  });
});

var _node = require("@modern-js/plugin/node");

Object.keys(_node).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _node[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _node[key];
    }
  });
});

var _commander = require("./utils/commander");

var _config = require("./config");

Object.keys(_config).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _config[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _config[key];
    }
  });
});

var _loadPlugins = require("./loadPlugins");

var _context = require("./context");

var _initWatcher = require("./initWatcher");

var _loadEnv = require("./loadEnv");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_commander.program.name('modern').usage('<command> [options]').version(process.env.MODERN_JS_VERSION || '0.1.0');

const hooksMap = {
  config: (0, _plugin.createParallelWorkflow)(),
  resolvedConfig: (0, _plugin.createAsyncWaterfall)(),
  validateSchema: (0, _plugin.createParallelWorkflow)(),
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  prepare: (0, _plugin.createAsyncWorkflow)(),
  commands: (0, _plugin.createAsyncWorkflow)(),
  watchFiles: (0, _plugin.createParallelWorkflow)(),
  fileChange: (0, _plugin.createAsyncWorkflow)(),
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  beforeExit: (0, _plugin.createAsyncWorkflow)(),
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  beforeRestart: (0, _plugin.createAsyncWorkflow)()
};
const manager = (0, _plugin.createAsyncManager)(hooksMap);
exports.manager = manager;
const {
  createPlugin,
  registe: registerHook,
  useRunner: mountHook
} = manager;
exports.mountHook = mountHook;
exports.registerHook = registerHook;
exports.createPlugin = createPlugin;

const usePlugins = plugins => plugins.forEach(plugin => manager.usePlugin((0, _utils.compatRequire)(require.resolve(plugin))));

exports.usePlugins = usePlugins;

const initAppDir = async cwd => {
  if (!cwd) {
    // eslint-disable-next-line no-param-reassign
    cwd = process.cwd();
  }

  const pkg = await (0, _utils.pkgUp)({
    cwd
  });

  if (!pkg) {
    throw new Error(`no package.json found in current work dir: ${cwd}`);
  }

  return _path.default.dirname(pkg);
};

exports.initAppDir = initAppDir;

const createCli = () => {
  let hooksRunner;
  let isRestart = false;
  let restartWithExistingPort = 0;
  let restartOptions;

  const init = async (argv = [], options) => {
    var _options$options$meta, _options$options;

    (0, _node.enable)();
    manager.clear();
    restartOptions = options;
    const appDirectory = await initAppDir();
    const metaName = (_options$options$meta = options === null || options === void 0 ? void 0 : (_options$options = options.options) === null || _options$options === void 0 ? void 0 : _options$options.metaName) !== null && _options$options$meta !== void 0 ? _options$options$meta : 'MODERN';
    (0, _loadEnv.loadEnv)(appDirectory, process.env[`${metaName.toUpperCase()}_ENV`]);
    const loaded = await (0, _config.loadUserConfig)(appDirectory, options === null || options === void 0 ? void 0 : options.configFile, options === null || options === void 0 ? void 0 : options.packageJsonConfig);
    const plugins = (0, _loadPlugins.loadPlugins)(appDirectory, loaded.config, {
      internalPlugins: options === null || options === void 0 ? void 0 : options.plugins,
      transformPlugin: options === null || options === void 0 ? void 0 : options.transformPlugin
    });
    plugins.forEach(plugin => plugin.cli && manager.usePlugin(plugin.cli));
    const appContext = (0, _context.initAppContext)(appDirectory, plugins, loaded.filePath, options === null || options === void 0 ? void 0 : options.options);
    manager.run(() => {
      _context.ConfigContext.set(loaded.config);

      _context.AppContext.set(appContext);
    });
    hooksRunner = await manager.init();
    ['SIGINT', 'SIGTERM', 'unhandledRejection', 'uncaughtException'].forEach(event => {
      process.on(event, async err => {
        await hooksRunner.beforeExit();

        if (err instanceof Error) {
          _utils.logger.error(err.stack);
        }

        process.nextTick(() => {
          // eslint-disable-next-line no-process-exit
          process.exit(1);
        });
      });
    });
    const extraConfigs = await hooksRunner.config();
    const extraSchemas = await hooksRunner.validateSchema();
    const config = await (0, _config.resolveConfig)(loaded, extraConfigs, extraSchemas, restartWithExistingPort, argv, options === null || options === void 0 ? void 0 : options.onSchemaError);
    const {
      resolved
    } = await hooksRunner.resolvedConfig({
      resolved: config
    }); // update context value

    manager.run(() => {
      _context.ConfigContext.set(loaded.config);

      _context.ResolvedConfigContext.set(resolved);

      _context.AppContext.set(_objectSpread(_objectSpread({}, appContext), {}, {
        port: resolved.server.port,
        distDirectory: (0, _utils.ensureAbsolutePath)(appDirectory, resolved.output.path)
      }));
    });
    await hooksRunner.prepare();
    return {
      loadedConfig: loaded,
      appContext,
      resolved
    };
  };

  async function run(argv, options) {
    const {
      loadedConfig,
      appContext,
      resolved
    } = await init(argv, options);
    await hooksRunner.commands({
      program: _commander.program
    });
    (0, _initWatcher.initWatcher)(loadedConfig, appContext.appDirectory, resolved.source.configDir, hooksRunner, argv);
    manager.run(() => _commander.program.parse(process.argv));
  }

  async function restart() {
    var _AppContext$use$value, _AppContext$use$value2;

    isRestart = true;
    restartWithExistingPort = isRestart ? (_AppContext$use$value = (_AppContext$use$value2 = _context.AppContext.use().value) === null || _AppContext$use$value2 === void 0 ? void 0 : _AppContext$use$value2.port) !== null && _AppContext$use$value !== void 0 ? _AppContext$use$value : 0 : 0;

    _utils.logger.info('Restart...\n');

    let hasGetError = false;
    const runner = manager.useRunner();
    await runner.beforeRestart();

    try {
      await init(process.argv.slice(2), restartOptions);
    } catch (err) {
      console.error(err);
      hasGetError = true;
    } finally {
      if (!hasGetError) {
        manager.run(() => _commander.program.parse(process.argv));
      }
    }
  }

  return {
    init,
    run,
    restart
  };
};

const cli = createCli();
exports.cli = cli;