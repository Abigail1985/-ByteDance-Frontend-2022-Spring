function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { loadConfig } from '@modern-js/load-config';
import Ajv from 'ajv';
import ajvKeywords from 'ajv-keywords';
import logger from 'signale';
import { createDebugger, getPort, isDev, PLUGIN_SCHEMAS, chalk } from '@modern-js/utils';
import mergeWith from 'lodash.mergewith';
import betterAjvErrors from 'better-ajv-errors';
import { codeFrameColumns } from '@babel/code-frame';
import { repeatKeyWarning } from "../utils/repeatKeyWarning";
import { defaults } from "./defaults";
import { mergeConfig } from "./mergeConfig";
import { patchSchema } from "./schema";
const debug = createDebugger('resolve-config');
export { defaults as defaultsConfig };
export { mergeConfig };
export const defineConfig = config => config;
export const loadUserConfig = async (appDirectory, filePath, packageJsonConfig) => {
  const loaded = await loadConfig(appDirectory, filePath, packageJsonConfig);
  const config = !loaded ? {} : await (typeof loaded.config === 'function' ? loaded.config(0) : loaded.config);
  return {
    config: mergeWith({}, config || {}, (loaded === null || loaded === void 0 ? void 0 : loaded.pkgConfig) || {}),
    jsConfig: config || {},
    pkgConfig: (loaded === null || loaded === void 0 ? void 0 : loaded.pkgConfig) || {},
    filePath: loaded === null || loaded === void 0 ? void 0 : loaded.path,
    dependencies: (loaded === null || loaded === void 0 ? void 0 : loaded.dependencies) || []
  };
};

const showAdditionalPropertiesError = error => {
  if (error.keyword === 'additionalProperties' && error.params.additionalProperty) {
    const target = [error.instancePath.slice(1), error.params.additionalProperty].filter(Boolean).join('.');
    const name = Object.keys(PLUGIN_SCHEMAS).find(key => PLUGIN_SCHEMAS[key].some(schemaItem => schemaItem.target === target));

    if (name) {
      logger.warn(`The configuration of ${chalk.bold(target)} is provided by plugin ${chalk.bold(name)}. Please use ${chalk.bold('yarn new')} to enable the corresponding capability.\n`);
    }
  }
};
/* eslint-disable max-statements, max-params */


export const resolveConfig = async (loaded, configs, schemas, restartWithExistingPort, argv, onSchemaError = showAdditionalPropertiesError) => {
  var _validate$errors;

  const {
    config: userConfig,
    jsConfig,
    pkgConfig
  } = loaded;
  const ajv = new Ajv({
    $data: true,
    strict: false
  });
  ajvKeywords(ajv);
  const validateSchema = patchSchema(schemas);
  const validate = ajv.compile(validateSchema);
  repeatKeyWarning(validateSchema, jsConfig, pkgConfig); // validate user config.

  const valid = validate(userConfig);

  if (!valid && (_validate$errors = validate.errors) !== null && _validate$errors !== void 0 && _validate$errors.length) {
    var _validate$errors2;

    onSchemaError(validate === null || validate === void 0 ? void 0 : validate.errors[0]);
    const errors = betterAjvErrors(validateSchema, userConfig, (_validate$errors2 = validate.errors) === null || _validate$errors2 === void 0 ? void 0 : _validate$errors2.map(e => _objectSpread(_objectSpread({}, e), {}, {
      dataPath: e.instancePath
    })), {
      format: 'js',
      indent: 2
    });
    logger.log(codeFrameColumns(JSON.stringify(userConfig, null, 2), {
      start: errors === null || errors === void 0 ? void 0 : errors[0].start,
      end: errors === null || errors === void 0 ? void 0 : errors[0].end
    }, {
      highlightCode: true,
      message: errors === null || errors === void 0 ? void 0 : errors[0].error
    }));
    throw new Error(`Validate configuration error`);
  } // validate config from plugins.


  for (const config of configs) {
    if (!validate(config)) {
      logger.error(validate.errors);
      throw new Error(`Validate configuration error.`);
    }
  }

  const resolved = mergeConfig([defaults, ...configs, userConfig]);
  resolved._raw = loaded.config;

  if (isDev() && argv[0] === 'dev') {
    if (restartWithExistingPort > 0) {
      // dev server is restarted, should use existing port number
      resolved.server.port = restartWithExistingPort;
    } else {
      // get port for new dev server
      resolved.server.port = await getPort(resolved.server.port);
    }
  }

  debug('resolved %o', resolved);
  return resolved;
};
/* eslint-enable max-statements, max-params */