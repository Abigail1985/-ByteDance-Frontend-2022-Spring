"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.build = void 0;

var _webpack = require("webpack");

var _webpack2 = require("@modern-js/webpack");

var _core = require("@modern-js/core");

var _utils = require("@modern-js/utils");

var _routes = require("../utils/routes");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// These sizes are pretty large. We'll warn for bundles exceeding them.
const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;

// eslint-disable-next-line max-statements
const build = async options => {
  /* eslint-disable react-hooks/rules-of-hooks */
  const resolvedConfig = (0, _core.useResolvedConfigContext)();
  const appContext = (0, _core.useAppContext)();
  const {
    existSrc
  } = appContext;
  /* eslint-enable react-hooks/rules-of-hooks */

  if (!existSrc) {
    const {
      distDirectory
    } = appContext;
    await (0, _utils.emptyDir)(distDirectory);
    await (0, _core.mountHook)().beforeBuild({
      webpackConfigs: []
    });
    await (0, _routes.generateRoutes)(appContext);
    await (0, _core.mountHook)().afterBuild();
    return;
  }

  const webpackBuild = async (webpackConfig, type) => {
    const compiler = (0, _webpack.webpack)(webpackConfig);
    return new Promise((resolve, reject) => {
      let label = process.env.NODE_ENV || '';

      if (type && type !== 'legacy') {
        label += ` ${type}`;
      }

      _utils.logger.info(`Creating a ${label} build...`);

      compiler.run((err, stats) => {
        let messages;

        if (!err) {
          messages = (0, _utils.formatWebpackMessages)(stats.toJson({
            all: false,
            warnings: true,
            errors: true
          }));

          if (messages.errors.length === 0) {
            _utils.logger.info(`File sizes after ${label} build:\n`);

            (0, _utils.printFileSizesAfterBuild)(stats, previousFileSizes, distDirectory, WARN_AFTER_BUNDLE_GZIP_SIZE, WARN_AFTER_CHUNK_GZIP_SIZE);

            _utils.logger.log();
          }
        } // When using run or watch, call close and wait for it to finish before calling run or watch again.
        // Concurrent compilations will corrupt the output files.


        compiler.close(closeErr => {
          if (closeErr) {
            _utils.logger.error(closeErr);
          }

          if (err) {
            reject(err);
          } else {
            if (messages.errors.length) {
              reject(new Error(messages.errors.join('\n\n')));
              return;
            }

            resolve({
              warnings: messages.warnings
            });
          }
        });
      });
    });
  };

  _core.manager.run(() => {
    _core.ResolvedConfigContext.set(_objectSpread(_objectSpread({}, resolvedConfig), {}, {
      cliOptions: options
    }));
  });

  const {
    distDirectory
  } = appContext;
  const previousFileSizes = await (0, _utils.measureFileSizesBeforeBuild)(distDirectory);
  await (0, _utils.emptyDir)(distDirectory);
  const buildConfigs = [];
  buildConfigs.push({
    type: 'legacy',
    config: (0, _webpack2.getWebpackConfig)(_webpack2.WebpackConfigTarget.CLIENT)
  });

  if (resolvedConfig.output.enableModernMode) {
    buildConfigs.push({
      type: 'modern',
      config: (0, _webpack2.getWebpackConfig)(_webpack2.WebpackConfigTarget.MODERN)
    });
  }

  if ((0, _utils.isUseSSRBundle)(resolvedConfig)) {
    buildConfigs.push({
      type: 'ssr',
      config: (0, _webpack2.getWebpackConfig)(_webpack2.WebpackConfigTarget.NODE)
    });
  }

  await (0, _core.mountHook)().beforeBuild({
    webpackConfigs: buildConfigs.map(({
      config
    }) => config)
  });

  for (const buildConfig of buildConfigs) {
    const {
      type: buildType,
      config
    } = buildConfig;

    try {
      await webpackBuild(config, buildType);
    } catch (error) {
      (0, _utils.printBuildError)(error); // eslint-disable-next-line no-process-exit

      process.exit(1);
    }
  }

  await (0, _routes.generateRoutes)(appContext);
  await (0, _core.mountHook)().afterBuild();
};

exports.build = build;